% !!! A socket provides a bidirectional communication endpoint for sending and receiving data with another socket.


% !TEX encoding = IsoLatin2

% LaTeX Template Version 3.1,  JuLY 2011
% by Dr. Andreas Drauschke (andreas.drauschke@technikum-wien.at) and Dr. Susanne Teschl (susanne.teschl@technikum-wien.at)
% minor adaptations by Harald Stockinger (harald.stockinger@technikum-wien.at)
%
% Adaptions for MR done by M. Widrich (BMR6) in January 2012, tested by W. Kubinger in March 2012
%
% Fragen zu den BMR- und MMR-Vorlagen bitte an Wilfried Kubinger (kubinger@technikum-wien.at) richten.
%
% Angepasst an MMR4, SS2013: 27.2.2013, WK
%


\documentclass[a4paper,bibtotoc,oneside]{scrbook}
% For short papers the documentclass "scrartcl" is sufficient. In this case the highest sectioning structure is "section" ("chapter" does not exist).
% \documentclass[a4paper,bibtotoc,oneside]{scrartcl}

\usepackage{hyperref}

\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman,english]{babel}
\selectlanguage{english}
\usepackage{amsmath,amssymb,amsfonts,amstext}

\usepackage{fancyhdr}
\lfoot[\fancyplain{}{}]{\fancyplain{}{}}
\rfoot[\fancyplain{}{}]{\fancyplain{}{}}
\cfoot[\fancyplain{}{\footnotesize\thepage}]{\fancyplain{}{\footnotesize\thepage}}
\lhead[\fancyplain{}{\footnotesize\nouppercase\leftmark}]{\fancyplain{}{}}
\chead{}
\rhead[\fancyplain{}{}]{\fancyplain{}{\footnotesize\nouppercase\sc\leftmark}}

\usepackage{color}

\usepackage{listings} %package for code
\lstset{language=C, basicstyle=\footnotesize}

\usepackage{multicol} %columns

\usepackage{helvet}
\renewcommand{\familydefault}{cmss}

\usepackage[pdftex]{graphicx}

\usepackage{harvard}

\usepackage{array}

\setlength{\textheight}{225mm}
\setlength{\textwidth}{1.05\textwidth}

\DeclareGraphicsExtensions{.jpg, .png}

\tolerance = 9999
\sloppy

% Anpassung einiger "Uberschriften
\renewcommand\figurename{Figure}
\renewcommand\tablename{Table}

% Abbildungen, Gleichungen und Tabellen werden fortlaufend nummeriert
\renewcommand\thefigure{\arabic{figure}}
\renewcommand\thetable{\arabic{table}}
\renewcommand\theequation{\arabic{equation}}
\usepackage{remreset}
\makeatletter
  \@removefromreset{figure}{chapter}
  \@removefromreset{table}{chapter}
  \@removefromreset{equation}{chapter}
\makeatother

%Zum korrekten Formatieren von Verzeichnissen
\usepackage{tocloft}
\renewcommand{\cftfigpresnum}{Figure~}
\renewcommand{\cfttabpresnum}{Table~}
\renewcommand{\cftfigaftersnum}{:}
\renewcommand{\cfttabaftersnum}{:}
\setlength{\cftfignumwidth}{2.5cm}
\setlength{\cfttabnumwidth}{2.5cm}
\setlength{\cftfigindent}{0cm}
\setlength{\cfttabindent}{0cm}

\begin{document}

%Festlegen des Zitier-Standards
\bibliographystyle{HarvardFHTWMR_V1_2e}%Zitierstandard FH Technikum Wien, Studiengang Mechatronik/Robotik
\citationstyle{dcu}%Correct citation-style (Harvardand, ";" between citations, "," between author and year)
\citationmode{abbr}%use "et al." with first citation
    \newcommand{\citepic}[1]{(Source: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Source: \protect\cite{#1}, p. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Source: taken with modification from \protect\cite{#1}, p. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Available at:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Available through:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Accessed}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{p.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{pp.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{Ch.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{Abstract only}
    \newcommand{\edition}{~edition}%Edition -> note, that you have to write "edition = {2nd},"!

\pagestyle{fancy}

% title page:
\thispagestyle{empty}
\begin{picture}(0,0)
\color{white}\sffamily
\put(-101,-749){\includegraphics[width=1.002\paperwidth, height=\paperheight]{BM_2011.pdf}}
\put(220,-670){\includegraphics[width=0.5\textwidth]{FHTW_Logo_4c.pdf}}
\put(-30, -20){\bfseries\huge BACHELOR'S PAPER}
% insert degree program:
\put(-30,-50){\Large Degree Program Mechatronic/Robotic}


\put(-32,-150){
\begin{minipage}{14cm}
\bfseries\huge
% insert title:
Event synchronization for micro controller in a local network
\end{minipage}
}
% insert author:
\put(-30,-250){\large By: Birgit Schreiber}
% insert student ID:
\put(-30,-270){\large Student Number: mr11b068}
% insert supervisor:
\put(-30,-310){\large Supervisor: Dipl. Ing. Dipl. Ing. Zoltan Puskas}
\put(-30,-350){\large Vienna, \today}
\color{black}
\end{picture}

\newpage

\section*{Declaration}\thispagestyle{empty}
I confirm that this paper is entirely my own work. All sources and quotations have been fully acknowledged in the appropriate places
with adequate footnotes and citations. Quotations have been properly acknowledged and marked with appropriate punctuation.
The works consulted are listed in the bibliography. This paper has not been submitted to another examination panel in the same or a
similar form, and has not been published. I declare that the present paper is identical to the version uploaded.
\\[5\baselineskip]
\rule{5cm}{0.2pt}\hfill\rule{5cm}{0.2pt}\\
\phantom{Datum }Place, Date\hfill Signature\hspace{15mm}

\newpage

% German abstract:
% \section*{Kurzfassung}\thispagestyle{empty}
% Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text ...
% \\ \vfill
% Please insert 3-5 German keywords that characterize the thesis:
% \paragraph*{Schlagw{\"o}rter:} Schlagwort 1, Schlagwort 2, Schlagwort 3, Schlagwort 4, Schlagwort 5

\newpage

% English abstract:
\section*{Abstract}\thispagestyle{empty}
Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text ...
\\ \vfill
% Please insert 3-5 English keywords that characterize the thesis:
\paragraph*{Keywords:} time, synchronization, micro controller, network, package 
 
\newpage

% Acknowledgments = complete
\section*{Acknowledgments}
\thispagestyle{empty}
First I would like to thank the company "Dension" for giving me the opportunity to do an internship. The internship woke my interest for software development
and digital science. 
I also want to thank IAEST-Budapest for organizing my accommodation and all the great spare time activities. It was a great experience, to do an internship
in a foreign country and experience a other culture.
Especially I want to thank my mentor and supervisor Zoltan Puskas, who took a lot of time and effort to supervise me during my internship. 
He thought me a lot and inspired me in many ways.

\newpage
\tableofcontents\thispagestyle{empty}

\newpage
\setcounter{page}{1}

% Introduction = complete
\chapter{Introduction}

This thesis is a report about a projects which was carried out during a internship at the company "Dension" in Budapest. 
This internship was part of the B.Sc. program Mechanics/Robotics at the university of applied science Technikum-Wien. 
The company "Dension" is an automotive electronic company which sells micro controllers which are used for different purposes, for example 
as multimedia gateways for cars or other multimedia purposes.
These micro controllers are also used for playing video and audio content on screens which are located in shopping centers for example.
During my internship I worked in the development department of the company, I got an good insight into software development for micro controllers with 
limited resources and in UNIX based operation systems.

The topic of the thesis "event synchronization for micro controller" was a feature which was requested from costumers for the products the 
company produces. This topic was given to me because synchronization of digital devices is a common problem in computer science and as well in robotic, so I could
profit a lot form it.

% Subject area = complete
\section{Subject area - Synchronization in digital science}

Synchronization is a common problem in computer science and engineering. The internal clocks of computers and micro controllers are not very accurate,
 the problem is that that after some time all clocks differ due to cock drift. This is caused by different rates of the clocks with which time is counted. 
The synchronization problem is a problem which occurs in many technical applications. There are several problems which are caused by the fact that clocks on different devices are not in sync, specially in distributed systems which should fulfill a shared task. 

% Motivation !!!not complete !!!
\section{Personal motivation}

Time synchronization is a common problem in the field of digital science, % some applications 
To work out an individual solution for this problem was not only a requested feature form the company, it was also profitable for me because I could learn
a lot while working on the project.

% Problem description = !!nearly complete  !!
\section{Problem description}

The microcontrollers which are produced and distributed by the company work on a UNIX based operating system which is specially designed 
for their purpose and applications. These microcontrollers have very limited resources, like processing power and RAM. 
The company offers different models, the most sold model is the MPX.\\*
The MPX has the following specifications:
\begin{itemize}
    \item Kernl: Linux (32 Bit)
    \item CPU: 720 MHz
    \item RAM: 256MB@360MHz
    \item Flash 1MB to 8MB
    \item 32MB @ SD-Card 
\end{itemize}
The company got the request form several of their customers that they would like to synchronize events on devices which are connected in a local network. 
This feature was requested for example to start videos in sync on monitors which are accessed by different microcontrollers. 
So the company searched for a possibility to meet the needs of the costumer and synchronize different devices. It also had to be consider the resources available 
on the devises are limited and that the other functionalities of the are not constrained. Playing video and audio can take a lot of processing power, 
tests showed that playing a video and an audio content at the same time could take to 90 - 95\% of the CPU power. 
This fact has to be taken in account, because the synchronization should not lower the quality of the video and audio.
It was also an important point that that the synchronization get integrated in the existing player.

The task was to design, implement and test an application, which should enable to synchronize an event on microcntollers which are connected in a local network. 

% state of the art = complete
\section{State of the art}

There are already several solution for the synchronization problem. The first step to do, was to do an research on existing solution 
and to understand the implementation and algorithm of these solution. On basis of this knowledge it was consider which parts of existing solution 
could be used and what has to be implemented to find a optimal solution for the given problem. An other specification which arose through the request
from the customers was that there will be no internet connection in most situations.

\subsection{Existing synchronization solutions}

One solution for the synchronization problem is the Network Time Protocol (NTP) which is a networking protocol for clock synchronization for 
devices which are connected over a network. NTP is mainly used to synchronize computers over the Internet to high-precision timekeeping devices like atomic clocks.
These clocks can measure time very accurate and are used as reference. Implementations of NTP transmit 64-bit timestamps via User Datagram Protocol to 
the devices which should be adjusted. Than the clock on the device is set to the correct value or the clock rate is fastened or slowed down. 
If the clock rate is fastened or slowed it takes some time till the clock has the correct time.

For the given task simply setting up an implementation of NTP was not an option. This was due to several reasons. 
From the task description it was clear that a connection to the Internet will not be provided in most of the application cases. Also the fact that
NTP adjusts the clock on the device was a reason why it was not considered as solution for the given task, because the clocks have very in some 
cases very different rates and the clocks would be out of sync within a short period and a continuous synchronization was for the task, 
which is described in detail in the next point, not necessary. 

A further point which had to be taken into account when considering different solutions was that it was very important for the company, 
that the synchronization could be fully integrated in the already existing system with as less alterations of the existing structures as possible.

All considerations of the above described facts and problems led to the decision to design and implement a new simple protocol based on a similar algorithm as NTP
which is suitable for the task and also takes the integration of the implementation in the already existing programs and structures in account. 

Also other established time sync solutions like SNTP and PTP where considered but in conclusion for the given task they had the same weaknesses as described above. 

As described above a protocol should be designed which has for the task relevant benefits of the algorithm which is used in NTP. For that reason the way how NTP
works and how it is implemented was analyzed.

\subsubsection{NTP - Network Time Protocol}

In NTP packets for Satrum 0 clocks are transmitted via internet with UDP packages. To take the transmission delay and the variance
in transmission delays in account the delay form several runs is calculated and averaged with a modified version of Marzullo's algorithm". The time which is needed
till the message from the instance with the accurate clock is deliver to the device which should be adjusted is called transmission delay. The transmission
delay can not be measured directly because the internal clocks of the two instances have different times and there is always an offset. To be able to determine 
the transmission delay the round trip delay is measured. To measure the round trip delay a package is delivered from the first instance to the target device
and than the target device answerers to the first instance, the time from sending the first message till receiving the answer is called the round trip delay.
Every time when a packet was sent or received a timestamp is saved, from these timestamps the round trip delay and the offset can be calculated. \\* \\*
The round trip delay $\delta$ is calculated: 
$$\delta=(t_3-t_0)-(t_2-t_1)$$ \\*
The offset $\Theta$ is calculated:
$$\Theta=\frac{(t_1-t_0)+(t_2-t_3)}{2}$$ \\*
where\\*
$t_0$ is the timestamp when the packet was sent\\*
$t_1$ is the timestamp when the packet was received from the device\\*
$t_2$ is the timestamp when the response packet was sent from the device\\*
$t_3$ is the timestamp of the response packet reception.\\*
With the knowledge of this tow variables the clock frequency is adjusted to reduce the offset.

\chapter{General Design of the Solution}
 
For the solution of the given problem a simple protocol was designed with a master/slave configuration where packages are transmitted
over a local network. In the master/slave principle the master has unidirectional control over the other devices.
The master saves timestamps when sending and receiving a package from which the roundtrip delay is calculated for every device in the system. 

\section{Protocol}

In the regular working mode the master device broadcasts frequently packages to all devices in the network. These packages will be referred as "updates" 
in the further description, because the master always updates the current roundtrip delay with each sent package. 
All devices in the slave mode are listening for updates from a master. If a update is received from a slave the slave answers to the master immediately with a 
package which will be referred as "answer" from now on. The master device saves a timestamp every time it broadcast or receives a package. If the master receives
an answer package form a slave it calculates the roundtrip  delay $\delta$ and the transmission delay with the formulas:
$$\delta=(t_4-t_1)$$
$$\delta/2=(t_4-t_1)/2$$
This is a simplified formula of the one which is used in most NTP implementations. The formula could be simplified because tests showed that on these 
devices in a representative network the time span $(t_2-t_3)$ was up to 10 times smaller than the average variation in the transmission delay. 
This time span gets even smaller if no timestamps needs to be taken on the slave device and the slave device simply pings back to the master device.
If a synchronized event is requested the master devices broadcasts this information with the update and each slave can according to it's individual
transmission delay initialize the event.

\subsection{Packages}

There are two different types of packages which are transmitted over the network. The package which is broadcasted by the master, the update, and the answer which
is sent back to the master from the slave, the answer. Each package contains different information and based on this the message type can be identified from the 
receiving device.

\subsubsection{Update package}

The update packages contains different information which are described in detail below. These informations are brodcasted over the network periodically. \\

\textbf{Group ID:} \\
Within a network the devices can be grouped. This is a useful feature if you have device groups where each group should play different content but the
content within the group needs to be played in sync. In the configuration file a group ID can be set by the user for each device. Within each group a master
is elected who calculates the roundtrip delay for each slave within the same group. If a device receives a package from an device which is not in the same group
the message is not processed any further. The group ID of the master is transmitted in the update. The first step a slave device does after receiving an update is 
comparing the group ID from the sending master to the own group ID. If the group IDs are not matching the received message is not processed any further. \\

\textbf{Force:} \\
A device can be specified as master device in the configuration file. If this option was set by the user this variable is set to one otherwise it is zero.
This vale is for slaves not relevant, but if a master receives an update from an other master which is within the same group this parameter is important.
How this parameter is processed is described in detail at the chapter master election. This parameter is important to avoid conflicts where more than
one master occur in a system. \\

\textbf{The seconds of $t_1$ and the micro seconds of the timespamp $t_1$:} \\
Immediately before the update is broadcasted a timestamp is taken. The values of the timestamp is transmitted in the update as message ID. This message ID is
sent back from the slave in the answer. When the timestamp is taken the function \lstinline{gettimeofday()}, which is used for the timestamps, 
returns the type \lstinline{struct timeval}. The members of the struct \lstinline{tv_sec} and \lstinline{tv_usec} are of the type \lstinline{long int}. 
The size of a long int depends of the architecture of the device. The type \lstinline{int} or \lstinline{unsigned int} has the same size independent from the
architecture. Therefore the values had to be converted before they could be sent over the network. This type has the same size on all architectures, 
but each value also has to be converted from host byte order to network byte order before it can be transmitted.
% here a sentence why ... not architecture dependent, OS dependent
The \lstinline{htonl()} function converts the unsigned integer hostlong from host byte order to network byte order. %this is a quote from the man page !!!
Therefore the values from the timestamp $t_1$ are transmitted as \lstinline{unsigned int}. \\

\textbf{Next event in micro seconds:} \\
If the master device initializes an event the time to the event is added to the update. 
The value is calculated by the master device for every message new till the event, this is to give a security if one message is lost or not received by the slave. 
For this application a security factor of 3 had been chosen. The time is calculated in a way, 
that it is ensured that each device receives at regularly 3 messages before the event is started on all nodes in the system.
$$ Time to event = (intervalltime + max. trasmition delay) * security factor$$
The calculated value is broadcasted with the update in microseconds as a unsigned integer.
Each slave subtracts it's own roundtrip delay from the time till the event and starts a internal countdown. \\

\textbf{Array of struct device:} \\
The information about the current average transmission delay of each slave is needed in each update. 
The information is organized in a customized struct which was called device. This struct contains an IP and an transmission delay. 
The update contains a array of this struct, in which the individual values for each device are stored. If an event is requested, each slave searches it's own IP
in the array after receiving the message. Each device subtracts it's own transmission delay form the time till the event. 
The maximum number of nodes within a group is restricted with the size of this array, this restriction was set to 64.\\

\textbf{The preload ID:} \\
Before a event can be started the content which is requested in sync must be loaded on each device. If a new event is requested each slave first gets a 
notification that it should load the requested content. This notification is implemented as a ID which is enhanced by one every time a new event is requested.
The slave compares the last processed preload ID with the current one and starts notifies the player to load the requested content, if they are not equal. \\

\textbf{Requested content:} \\
This is implemented as an character array which holds the sync request and the filename of the content which should be synced next. 
If the slave receives a new preload request with the update it forwards the request hold in this string to the player. \\ 

\textbf{Event ID:} \\
The event ID is similar to the preload ID, if the event ID in the update is not equal to the last processed event ID the steps to initialize an event are taken. \\

The whole information of the package is collected in a packed struct before it is broadcasted. % if I need some more text I can here say what packed means and why !! 
The size of this whole structure is not bigger than 0.6 kB, which is a relative small package.

\subsubsection{Answer Package}

After the slave received an update from a master it replies to it with the answer package. 
The master receives this answer and calculates as described above the transmission delay for the slave. Over the calculated values a moving average is
built for each slave. \\

\textbf{Group ID:} \\
The slave adds his own group ID to the answer package. This information is important that a master does not process information from slaves which
are not in the same group. \\

\textbf{The seconds of $t_1$ and the micro seconds of the timespamp $t_1$:} \\
These two values are used as mentioned as message ID. They are received from the update and copied to the answer. 
The master device can use this value directly to calculate the roundtrip and transmission delay, after he received the answer. \\

\textbf{Ready ID:} \\
If the slave received a prelaod request and it has notified the player, the player confirms after he has successfully loaded the requested content.
If this confirmation arrives the slave copies the ID of the current preload request in the ready ID value. The master can compare the ready ID from the slave 
to the current preload ID, if they are equal the master marks the slave as ready. If all slaves are ready the time till the event can be calculated and
the event can be initialized.

\subsection{Master Election}

After the application has started in the first step a master has to be defined. In the network all nodes are equal and similar to each other but each one
has a unique IP address. A master device has to be elected within the system. Therefore a master election had to be designed as part of the program. 
There are two ways how a master can be found in this application. The first one is to set a device as the master manually. 
This can be done with an configuration option, which can be set by the user in the configuration file. The other way to find a master in the network is
a dynamic election. The dynamic election is put to use if no master was specified in a system. \\

\textbf{The user specifies a master:} \\*
The user has the possibility to specify a master in the configuration file. To specify the master the correlating option has to be set in the configuration file. 
If this configuration option is set to true there will be no further dynamic election of any master in the system. 
If two master would be specified a conflict would arise. To prevent errors which would arise with two specified master only one master is allowed in a system. 
To make sure only one master exists at any time within the same system one master is discarded if there are more than one. 
To decide which master has to be terminated the IPs of the devices are compared.
The specified master with the higher IP continues as master and on the other device the application terminates and an error message is printed 
on the output screen for the user. The error message informs the user that only one master can be specified within the same group and asks the user to check
the configurations. \\

\textbf{Dynamic election of the master:} \\*
If no master was specified by the user the election of the master is dynamic and automatically by the program. 
When the master election was implemented all situations how devices can be added to the network had to be considered. 
The following scenarios where considered when designing the dynamic election: \\
\begin{itemize}
    \item only one device is in the system 
    \item a device gets added to a system with a already existing master
    \item the master device in the system is shut down
    \item a device which is specified as master gets added to a network with a dynamic elected master
    \item a slave device is reconfigured as master during the run time in the network 
    \item several devices are added to a system with no master at the exact same time, for example after a blackout
\end{itemize}

\subsubsection[Implementation of the master election]{Implementation of the master election}

The basic principle for the master election is that a devices switches in master mode if no master is in the system. If two masters occur in the same
system the IP addresses of the two masters are compared and the device with happens to have the higher IP remains as only master. The master
election was designed that the already defined package types, which are necessary for the regular work mode, could be used. \\*

When the application is started the configuration file is read. If in the configuration option is set that the device should be the master, 
the program starts as master and a global variable \lstinline{b_force} is set to one. This variable is also included in the updates which are broadcasted 
over the network. If the device was not specified as master the program starts in slave mode and listens for updates. 
If a update is received from a master with the same group ID an answer package is sent. 
If no update is received for a defined time period the device becomes a master. The time how long the slave waits for an update is defined as
\lstinline{L_INT_WAITTIME}, and set in this application to 3 seconds. \\

The master and slave mode are implemented as functions which are called by  the main function, each mode contains a infinite loop from which is braked out 
if the stop signal is set. \\
The stop signal is set in the following situations:
\begin{itemize}
    \item the slave function does not receive an update
    \item if a dynamic elected master received an update from a specified master  
    \item if a specified master received an update from a specified master with an higher IP
    \item if a dynamic elected master received an update from a other dynamic elected master with an higher IP
\end{itemize}

Before the function returns all allocated memory is freed by a cleanup handler. In the main function the next mode/function is called after a mode returned. 
This is also implemented in a infinite loop so that a slave which became master can become a slave again. For example when a other master which was specified 
by the user is added to the system. Before the master function returns all threads which where called in the function are terminate and the in each thread the
allocated memory is freed and the mutex variables which are hold currently by the thread are unlocked.
After all threads exited the function returns. If the master was a dynamic elected master he starts in slave mode, 
if the master was already a specified one a error message informs the user that two specified master are currently in the system and the application terminates.

\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{master-election}

\subsection{Final design of the Protocol}

In the following section it is shown how the final design of the protocol combines the regular work mode with the master election and how
the different package types are used. Therefore the protocol was visualized with a message sequence chart. 
The purpose of a MSC (Message Sequence Chart) is to provide a language to specify and describe the communication behavior of system components 
and their environment by means of message interchange. % direct wiki quote !!!
To visualize the protocol with a MSC also was an necessary and important step to design the application, because through the visualizing conflicts
which could occur are pointed out.

\newpage

\begin{multicols}{2}

\includegraphics[width=0.45\textwidth,trim = 0mm 20mm 0mm 0mm,clip,keepaspectratio]{workingmode1.png} \\ \\

When the devices is added to a system it starts in slave mode. Here it can been seen that device B is in the 
begin the only device in the system. After some time the devices A, C and D are also switched on. In the
slave mode the application is waiting for an update from a master. 

If no update is received in the slave mode the device switches to the master mode. Here the device B switches
at first in the master mode, because it was started at first and the timeout for waiting for an update is
already over on this device. In the master mode the device starts to broadcast updates to each node in 
the network. The other devices stay in save mode because an update was received. Each device pings back to
the master device.

When the device is taken off the network which was dynamically elected as master, no more updates are broadcasted
over the network. In this case the device B is removed from the system. After no update was received all the
remaining devices switch in the master mode. Here it can be seen that device A, C and D are now in the master mode.
After a master receives a master message it compares it's own IP to the one from the other master. If the own
IP is lower it switches back to slave mode again. In this example, device C and D turn into slaves again, A 
remains the master and continues broadcasting updates.

If a devices is added to a network where there is already a master it just starts to answer to the received
updates. In this case device B is turned on again an is now a slave node.

If a slave node is taken off the network, it can't reply anymore to updates. The master device deletes 
a slave device which is not responding for a period from it's intern list.

\end{multicols}

\newpage

\begin{multicols}{2}
\includegraphics[width=0.45\textwidth,keepaspectratio]{workingmode2.png} \\ \\ \\

If a device is added to a system where already a dynamically elected master exists, the specified master starts
to broadcast updates, where the information that it is a forced master is contained in the update. The other 
master reads this information, if it receives an update from an master and switches in slave mode and starts to
respond to the new master. Also all the other devices start to respond to the new master.
\end{multicols}

With this design of the protocol only two types of packages are needed and both the dynamical as the manual election of a master device is integrated in
the regular working mode.

\chapter{Implementation}

% quotes from adventagesC 
The application was implemented in the programing language C. C is especially good for programming with limited resources, the language is very close
to the machine and therefor specially suited for microcontrollers. With C every resource a computer offers can be used. C is also the language which is currently most used to program UNIX systems, for example most of the GNU project is written in C. Also an other main advantage of C is the speed of the resulting application, C
code can be optimized much more than higher-level languages and the language set is very efficient. % !!!direct quote wiki.answers.com/Q/What_is_the_advantage_of
%_c_language. 
C is a very powerful programming language, it is best used for data structures and designing system software. % !!!direct quote iimchyderabad.com/Material/cnotes.pdf

\section{Communication UTP}

% all qutes from the Illustrated network 
For transmitting the so far described package the User Datagram Protocol was used.
The User Datagram Protocol (UTP) is a transport layer  protocol that rides on top of IPv4 or IPv6, that enables sending messages between devices over a network.
UDP uses a very simple transmission model and provides only a minimal protocol mechanism. It does not provide any control mechanisms, therefore there is no guarantee 
of the delivery of the packages. There is also no guarantee for the order in which the messages arrive and also no duplicate protection.
UTP is used for application where error checking and correction is not necessary or done by the application, which uses it, itself.
If error checking is needed at the network interface level other protocols like the Transmission Control Protocol (TCP) or the Stream Control Transmission 
Protocol (SCTP) must be used. Tu sum it up, UDP is a low-overhead transport for applications that do not need guaranteed delivery like provided by TCP.
The advantages of UDP lie in it's simplicity, the simple operation of UTP make it fast and therefor ideal for delay-sensitive traffic.
Time-sensitive application could suffer from waiting for all the overhead that TCP requires to set up a connection between hosts before sending a message.
Also for time-sensitive application dropping packages is preferable to waiting for delayed messages.
UTP is transaction-oriented which makes it most suitable for simple protocols. UTP is also stateless what allows a very large number of clients.
It is also suitable for broadcasting information.

For this project one of the main advantage was the lack of delivery control mechanism and the resulting speed of the Protocol.
Therefore in the event synchronization application the communication between the devices is established with the User Datagram Protocol (UDP), 

\subsection{Prepare connection}

In order for the application to be able to send and receive UTP packets an interface between the application and the network is necessary, this is 
provided by so called sockets. The application creates the socket, where the socket type defines the communication type, 
UTP for example uses \lstinline{SOCK_DGRAM} sockets. A socket is a bidirectional communication endpoint which can transmit or receive data from an other socket. \\

To set up a sockets for communication the following steps must be performed in the code:
\begin{itemize}
    \item Creating a socket by calling \lstinline{socket()},
    \item Binding the socket by calling \lstinline{bind()} and provide a \lstinline{struct sockaddr} in which the family and port which sound be used are defined
\end{itemize}
    
When transmitting packets with UTP the connection is not established before sending the message. The client for example sends a packet with 
\lstinline{sendto()} without connecting first to the server, when UTP is used the server also does not accept a connection, the server immediately calls
\lstinline{recvfrom()} and waits for any data. In a bidirectional communication like accomplished with the above outlined commands the sever and the client can 
send and receive packages.

\subsubsection{Broadcast messages}

For the application it is necessary not only to send packages between two devices, it is also needed to broadcast information. For example the updates from
the master should be broadcasted. When messages are broadcasted, each device in the network receives the message without being addressed.



%broadcasting and calculating broadcast address

%steps: create a udp socket, get/claculate the address, REUSEADDR, bind, setsocketopt, sendto, recvfrom

\section[Master-mode]{Master-mode}

\subsection[threads]{threads}

\section[Slave-mode]{Slave-mode}

\chapter[Integration]{Integration}

\section[Communication with pipe]{Communication with pipe}

\section[Options for user]{Options for user}

configuration
The user has the possibiliy to set several configuration options for the time synchronisation.
This options can be set in the configuration file. (here it would be nice how the user can set them, of the perspective of the usre)

sync\_enabled: this optin secifys if the timesyncronisation is active on the device. A script is run in the background on the divice all the time wich checks for the configuration files and starts programs or stops them if the configuration is changed. After the divices is botted the script reads the confiugfiles once and starts all of the configurateable programs.

sync\_group\_id: the devices within the same network can be grouped, this option is imported because diffrent devices in the same network can also play dfferen contend wiht the groups zou can specify wicht devices in the nework should be synced togeteher if a syncronzed event is requested. If this configuration option is set to -1 which is also the default configuration the syncdaemon is not executed because the device would not sync to any other device. In the udp packages the the group id is trasmited as well and if the group id of the received masseg does not fit the group id of the divces the package is not process any furtehr.

sync\_group\_order: wiht the group order a order within the group can be deifend. This can be useful if the deivies should play differnet conted syncronized. For example different screeen wich are orderd next to each other and where each display shows only a part of the same picture (or for example two robots wich coloperate, each one does a different action but the event must be in perfect sync).

sync\_forced\_master: (here it would be nice to know why the user needs this option) The syncdaemon is implemetnned in this way that one divice is collecting all the data and initalizes the event if requested form the controllerfifo. If this option is not set the master is selected dynamically. If this option is set this devices becomes the amster. If an dynamiacally selecteed master already exists the old master returns to slave mode. If to masters are specifed masters within the same group one of them returns an error and notificates the user that there is only one specified master alowed in one system.

sync\_wait: due to the timedrift the played content gets out of sync, if contend should be played in sync and one device has not finished the other contend yet, there are two options. The default option is that the wait option is set. In this case the devieces wati for each other and then start the synced conted this can cause the screan to show no conted for a short period (usually not loger than 1 to 2 seconds) if this should be avoided the the option can be set to false, in this case the device is playing some ohter contetd wich must not be in sync but if all devices finished the old contend the new conted will be interuped. For this option also special conted can be specifed, for this purpuse pictures would be a good option.



% Literaturverzeichnis
\bibliography{Vorlage_BT_BMR_WS2013_Literatur}
\newpage

% Abbildungsverzeichnis und Tabellenverzeichnis
\begingroup
    \renewcommand*{\addvspace}[1]{}
    \phantomsection
    \addcontentsline{toc}{chapter}{\listfigurename}
    \listoffigures
    \newpage
    \phantomsection
    \addcontentsline{toc}{chapter}{\listtablename}
    \listoftables
\endgroup


% If you use the document class "scrartcl" you need to use  \addsec{List of Abbreviations} instead of \addchap{List of Abbreviations}
\addchap{List of Abbreviations}
\hspace{-17mm}\begin{tabular}{>{\raggedleft}p{0.2\linewidth} p{0.75\linewidth} p{0.1\linewidth}}
www & World Wide Web \\
URL & Uniform Resource Locator
\end{tabular}

\begin{appendix}
\chapter[Source Code]{Source Code}

% here comes my hole source in the end

\end{appendix}

\end{document}
