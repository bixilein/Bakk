% !!! A socket provides a bidirectional communication endpoint for sending and receiving data with another socket.


% !TEX encoding = IsoLatin2

% LaTeX Template Version 3.1,  JuLY 2011
% by Dr. Andreas Drauschke (andreas.drauschke@technikum-wien.at) and Dr. Susanne Teschl (susanne.teschl@technikum-wien.at)
% minor adaptations by Harald Stockinger (harald.stockinger@technikum-wien.at)
%
% Adaptions for MR done by M. Widrich (BMR6) in January 2012, tested by W. Kubinger in March 2012
%
% Fragen zu den BMR- und MMR-Vorlagen bitte an Wilfried Kubinger (kubinger@technikum-wien.at) richten.
%
% Angepasst an MMR4, SS2013: 27.2.2013, WK
%


\documentclass[a4paper,bibtotoc,oneside]{scrbook}
% For short papers the documentclass "scrartcl" is sufficient. In this case the highest sectioning structure is "section" ("chapter" does not exist).
% \documentclass[a4paper,bibtotoc,oneside]{scrartcl}

\usepackage{hyperref}

\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman,english]{babel}
\selectlanguage{english}
\usepackage{amsmath,amssymb,amsfonts,amstext}

\usepackage{fancyhdr}
\lfoot[\fancyplain{}{}]{\fancyplain{}{}}
\rfoot[\fancyplain{}{}]{\fancyplain{}{}}
\cfoot[\fancyplain{}{\footnotesize\thepage}]{\fancyplain{}{\footnotesize\thepage}}
\lhead[\fancyplain{}{\footnotesize\nouppercase\leftmark}]{\fancyplain{}{}}
\chead{}
\rhead[\fancyplain{}{}]{\fancyplain{}{\footnotesize\nouppercase\sc\leftmark}}

\usepackage{color}

\usepackage{listings} %package for code
\lstset{language=C, basicstyle=\footnotesize}

\usepackage{multicol} %columns

\usepackage{lscape} %make a page landscape

\usepackage{helvet}
\renewcommand{\familydefault}{cmsy}

\usepackage[pdftex]{graphicx}

\usepackage{harvard}

\usepackage{array}

\setlength{\textheight}{225mm}
\setlength{\textwidth}{1.05\textwidth}

\DeclareGraphicsExtensions{.jpg, .png, .gif}

\tolerance = 9999
\sloppy

% Anpassung einiger "Uberschriften
\renewcommand\figurename{Figure}
\renewcommand\tablename{Table}

% Abbildungen, Gleichungen und Tabellen werden fortlaufend nummeriert
\renewcommand\thefigure{\arabic{figure}}
\renewcommand\thetable{\arabic{table}}
\renewcommand\theequation{\arabic{equation}}
\usepackage{remreset}
\makeatletter
  \@removefromreset{figure}{chapter}
  \@removefromreset{table}{chapter}
  \@removefromreset{equation}{chapter}
\makeatother

%Zum korrekten Formatieren von Verzeichnissen
\usepackage{tocloft}
\renewcommand{\cftfigpresnum}{Figure~}
\renewcommand{\cfttabpresnum}{Table~}
\renewcommand{\cftfigaftersnum}{:}
\renewcommand{\cfttabaftersnum}{:}
\setlength{\cftfignumwidth}{2.5cm}
\setlength{\cfttabnumwidth}{2.5cm}
\setlength{\cftfigindent}{0cm}
\setlength{\cfttabindent}{0cm}

\begin{document}

%Festlegen des Zitier-Standards
\bibliographystyle{HarvardFHTWMR_V1_2e}%Zitierstandard FH Technikum Wien, Studiengang Mechatronik/Robotik
\citationstyle{dcu}%Correct citation-style (Harvardand, ";" between citations, "," between author and year)
\citationmode{abbr}%use "et al." with first citation
    \newcommand{\citepic}[1]{(Source: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Source: \protect\cite{#1}, p. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Source: taken with modification from \protect\cite{#1}, p. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Available at:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Available through:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Accessed}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{p.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{pp.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{Ch.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{Abstract only}
    \newcommand{\edition}{~edition}%Edition -> note, that you have to write "edition = {2nd},"!

\pagestyle{fancy}

% title page:
\thispagestyle{empty}
\begin{picture}(0,0)
\color{white}\sffamily
\put(-101,-749){\includegraphics[width=1.002\paperwidth, height=\paperheight]{BM_2011.pdf}}
\put(220,-670){\includegraphics[width=0.5\textwidth]{FHTW_Logo_4c.pdf}}
\put(-30, -20){\bfseries\huge BACHELOR'S PAPER}
% insert degree program:
\put(-30,-50){\Large Degree Program Mechatronic/Robotic}


\put(-32,-150){
\begin{minipage}{14cm}
\bfseries\huge
% insert title:
Event Synchronization for \\*Microcontroller in a Local Network
\end{minipage}
}
% insert author:
\put(-30,-250){\large By: Birgit Schreiber}
% insert student ID:
\put(-30,-270){\large Student Number: mr11b068}
% insert supervisor:
\put(-30,-310){\large Supervisor: Dipl. Ing. Dipl. Ing. Zoltan Puskas}
\put(-30,-350){\large Vienna, \today}
\color{black}
\end{picture}

\newpage

\section*{Declaration}\thispagestyle{empty}
I confirm that this paper is entirely my own work. All sources and quotations have been fully acknowledged in the appropriate places
with adequate footnotes and citations. Quotations have been properly acknowledged and marked with appropriate punctuation.
The works consulted are listed in the bibliography. This paper has not been submitted to another examination panel in the same or a
similar form, and has not been published. I declare that the present paper is identical to the version uploaded.
\\[5\baselineskip]
\rule{5cm}{0.2pt}\hfill\rule{5cm}{0.2pt}\\
\phantom{Datum }Place, Date\hfill Signature\hspace{15mm}

\newpage

% German abstract:
% \section*{Kurzfassung}\thispagestyle{empty}
% Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text ...
% \\ \vfill
% Please insert 3-5 German keywords that characterize the thesis:
% \paragraph*{Schlagw{\"o}rter:} Schlagwort 1, Schlagwort 2, Schlagwort 3, Schlagwort 4, Schlagwort 5

\newpage

% English abstract:
\section*{Abstract}\thispagestyle{empty}
Everyone uses multiple microcontrollers in their daily life for example in their
phones, MP3 player or as multimedia gateways. A problem that arises with the use of different microcontrollers is the synchronisation of the time on different devices. This is a specially challenging task if the devices which should be synchronized  have limited resources and no or no permanent connection to the internet. But for several uses it can be necessary to have synchronized clocks, for example to play content on different devices simultaneously. 
The company \textit{"Dension"}, which distributes microcontrollers for different purposes, was searching for a solution for this problem for their devices. 
This thesis describes the design and implementation of a solution for this problem, where the limited resources of the microcontroller and the integration in the 
existing system of the company had been taken in account. 
\\ \vfill
% Please insert 3-5 English keywords that characterize the thesis:
\paragraph*{Keywords:} time, synchronization, micro controller, network, package 
 
\newpage

% Acknowledgments
\section*{Acknowledgments}
\thispagestyle{empty}
First I would like to thank the company "Dension" for giving me the opportunity to do an internship. The internship woke my interest for software development
and digital science. 
I also want to thank IAEST-Budapest for organizing my accommodation and all the great spare time activities. It was a great experience, to do an internship
in a foreign country and experience a different culture.
Especially I want to thank my mentor and supervisor Zoltan Puskas, who took a lot of time and effort to supervise me during my internship. 

\newpage
\tableofcontents\thispagestyle{empty}

\newpage
\setcounter{page}{1}

% Introduction
\chapter{Introduction}

This thesis is a report about a project which was carried out during an internship at the company \textit{"Dension"} in Budapest. 
This internship was part of the B.Sc. program Mechatronics/Robotics at the university of applied science \textit{Technikum Wien}. 
The company \textit{"Dension"} is an automotive electronic company which sells microcontrollers which are used for different purposes, for example 
as multimedia gateways in cars. 
These microcontrollers are also used for other multimedia purposes, as playing video and audio advertisement in shopping centers.
During my internship I worked in the development department of the company, I got an good insight into software development for microcontrollers with 
limited resources and in UNIX based operating systems.

The topic of the thesis \textit{"Event Synchronization for Microcontroller"} was a feature which was requested from several costumers. 
This topic was given to me because synchronization of digital devices is a common problem in computer science and as well in robotic, so I could
profit a lot form it.

% Subject area
\section{Subject Area - Synchronization in Digital Science}

Synchronization is a common problem in computer science and engineering. 
The internal clocks of computers and microcontrollers are not very accurate, 
 because even if the clocks are synchronized when they start after some time all clocks differ due to cock drift. This drift is caused by different rates with which the internal time is counted, see also \citep{problem}.
The synchronization of digital devices is a problem which occurs in many technical applications. 
There are several problems which are caused by the fact that clocks on different devices are not in sync, specially in distributed systems 
which should fulfill a shared task. 
One example for the synchronization problem in robotic is, when it is needed to identify causal relationships
between events in the physical world, from sensors in different locations.

% Problem description
\section{Problem Description}

The microcontrollers which are produced and distributed by \textit{"Dension"} work on a UNIX based operating system which is specially designed 
for their purpose and applications. These microcontrollers have very limited resources, like processing power and RAM. 
The company offers different models, the most sold model is the MPX.
\newpage
The MPX has the following specifications:
\begin{itemize}
    \item Kernl: Linux (32 Bit)
    \item CPU: 720 MHz
    \item RAM: 256MB@360MHz
    \item Flash 1MB to 8MB
    \item 32MB @ SD-Card 
\end{itemize}
The company got the request form their customers that they would like to synchronize events on devices which are connected in a local network. 
This feature was requested for example to start videos in sync on monitors which are accessed by different microcontrollers. 
When searching a solution it had to be consider the resources available 
on the devises are limited and that the other functionalities must not be constrained. Playing video and audio can take a lot of processing power. 
Tests showed that playing a video and an audio content at the same time could take up to 90\% of the CPU power on the MPX. This had to be taken in account, because running the synchronization application should not lower the quality of the video and audio content.
It was also an important point that that the synchronization could be integrated in the existing player.
An other specification which arose through the request
from the customers was that there will be no connection to the internet in most situations.

In conclusion the task was to design, implement and test an application, which should give the possibility to synchronize an event on different devices.

% 
\section{State of the Art and Concept for a Solution}

There are already several solution for the synchronization problem. In the first step a research on existing solution was done.
The implementation and algorithm of these solutions were analyzed. On basis of this knowledge it was considered which parts of existing solution 
could be used and what had to be implemented to find a optimal solution for the given problem. \\* 

A common solution for the synchronization problem is the Network Time Protocol (NTP), it's concept is described in \citep[5.1. Basic Concepts]{NTP}. It is a networking protocol to synchronize clocks on 
devices which are connected over a network. 
NTP is mainly used to synchronize computers over the Internet to high-precision timekeeping devices like atomic clocks.
These clocks are capable of measuring the time very accurate and are used as reference. 
Implementations of NTP transmit timestamps via the User Datagram Protocol (UDP) to the devices which should be adjusted. 
Than the internal clock on the device is set to the correct value or the clock rate is fastened or slowed down, 
till an accurate time is reached. If the clock is adjusted by fastening or slowing the clock rate, it takes some time till an accurate time is reached on
the device.

For the given task simply setting up an implementation of NTP was not an satisfying option for several reasons.
From the task description it was clear that a connection to the Internet will not be provided in most of the application cases. Also the fact that
NTP adjusts the internal clock on the device was a reason why it was not considered as a optimal solution for the given task. Science the clock
 drift on these devices tends to be very significant, a synchronization would have been lost in a very short period of time.
Also a continuous synchronization was not necessary for the given task. 
A further point which had to be taken into account when considering different solutions was that it was very important for the company, 
that the synchronization could be fully integrated in the already existing system with as less alterations of the existing structures as possible.
Also other established time sync solutions like SNTP and PTP where considered but in conclusion for the given task they had the same weaknesses as NTP. \\*

All considerations of the above described facts led to the decision to design and implement a new simple protocol.
The new algorithm had to have the benefits of NTP and had to be suitable for the task and take the integration in the already existing programs and structures 
in account. In summery the resulting task was to designed a protocol which had the for the task relevant benefits of the algorithm used in NTP and which
enabled a integration in the existing programs. For that reason the way NTP works and how it is implemented had to be analyzed in detail.

\subsection{NTP - Network Time Protocol}

In NTP implementations packets for high precision clocks are transmitted via the internet to the nodes in a network. 
To take the transmission delay of the network and the variance in transmission delays in account, 
the delay form several runs is calculated and averaged.
The transmission delay is the time which is needed till the message from the instance with the accurate clock is deliver to the device which should be adjusted.
The transmission delay can not be measured directly because the internal clocks of  two instances always have different times with an offset to each other. 
To be able to determine the transmission delay the round trip delay is measured. 
To measure the round trip delay a package is delivered from the first instance to the target device
and than the target device answerers to the first instance. The time from sending the first message till receiving the answer is called the round trip delay.
Every time when a packet is sent or received timestamps are saved. From these time values the round trip delay and the offset can be calculated, as 
described in the documentation of an implementation of NTP(\citep[How NTP Works]{NTPdistro}). \\* \\*
The round trip delay $\delta$ is calculated: 
$$\delta=(t_3-t_0)-(t_2-t_1)$$ \\*
The offset $\Theta$ is calculated:
$$\Theta=\frac{(t_1-t_0)+(t_2-t_3)}{2}$$ \\*
where\\*
$t_0$ is the timestamp when the packet is sent\\*
$t_1$ is the timestamp when the packet is received from the device\\*
$t_2$ is the timestamp when the response packet is sent from the device\\*
$t_3$ is the timestamp of the response packet reception.\\*
With the knowledge of this two values the clock frequency is adjusted to reduce the offset.

\chapter{Design of the Solution}
 
For the solution of the given problem a simple protocol was designed with a master/slave configuration where packages are transmitted
over a local network. 
The application was designed that, the master had unidirectional control over the slave devices. 
In the designed program the master saves timestamps when sending and receiving a package from which the round trip delay is calculated, for every device in the system. 
The calculation were based on the formulas which are used in common NTP implementations. 

%hallo down (no quotes needed)
\section{Protocol}

In the regular working mode the master device broadcasts frequently packages to all devices in the network. These packages will be referred as "\textit{updates}" 
in the further description, because the master always \textit{updates} the current roundtrip delay with each sent package. 
All devices in the slave mode are listening for \textit{updates} from a master. If a \textit{update} is received from a slave the slave answers to the master immediately with a 
package which will be referred as "\textit{answer}" from now on. The master device saves a timestamp every time it broadcast or receives a package. If the master receives
an \textit{answer} package form a slave it calculates the roundtrip  delay $\delta$ and the transmission delay with the formulas:
$$\delta=(t_4-t_1)$$
$$\delta/2=(t_4-t_1)/2$$
This is a simplified formula of the one which is used in most NTP implementations. The formula could be simplified because tests showed that on these 
devices in a representative network the time span $(t_2-t_3)$ was up to 10 times smaller than the average variation in the transmission delay. 
This time span gets even smaller if no timestamps needs to be taken on the slave device and the slave device simply pings back to the master device.
If a synchronized event is requested the master devices broadcasts this information with the \textit{update} and each slave can according to it's individual
transmission delay initialize the event.

\subsection{Packages}

The algorithm was designed with two different types of packages which are transmitted over the network. The package which is broadcasted by the master, the \textit{update}, and the \textit{answer} which
is sent back to the master from the slave, the \textit{answer}. Each package contains different information and based on this the message type can be identified from the 
receiving device.

\subsubsection{Update Package}

The \textit{update} packages contains different information which are described in detail below. These informations are brodcasted over the network periodically. \\

\textbf{Group ID:} \\
Within a network the devices can be grouped. This is a useful feature if you have device groups where each group should play different content but the
content within the group needs to be played in sync. In the configuration file a group ID can be set by the user for each device. Within each group a master
is elected who calculates the roundtrip delay for each slave within the same group. If a device receives a package from an device which is not in the same group
the message is not processed any further. The group ID of the master is transmitted in the \textit{update}. The first step a slave device does after receiving an \textit{update} is 
comparing the group ID from the sending master to the own group ID. If the group IDs are not matching the received message is not processed any further. \\

\textbf{Force:} \\
A device can be specified as master device in the configuration file. If this option was set by the user this variable is set to one otherwise it is zero.
This vale is for slaves not relevant, but if a master receives an \textit{update} from an other master which is within the same group this parameter is important.
How this parameter is processed is described in detail at the chapter master election. This parameter is important to avoid conflicts where more than
one master occur in a system. \\

\textbf{The time value of $t_1$ in seconds and micro seconds:} \\
Immediately before the \textit{update} is broadcasted a timestamp is taken. The values of the timestamp is transmitted in the \textit{update} as message ID. This message ID is
sent back from the slave in the \textit{answer}. When the timestamp is taken the function \lstinline{gettimeofday()}, which is used for the timestamps, 
returns the type \lstinline{struct timeval}. The members of the struct \lstinline{tv_sec} and \lstinline{tv_usec} are of the type \lstinline{long int}. 
The size of a long int depends of the architecture of the device. The type \lstinline{int} or \lstinline{unsigned int} has the same size independent from the
architecture. Therefore the values had to be converted before they could be sent over the network. This type has the same size on all architectures, 
but each value also has to be converted from host byte order to network byte order before it can be transmitted.
% here a sentence why ... not architecture dependent, OS dependent
The \lstinline{htonl()} function converts the unsigned integer hostlong from host byte order to network byte order. %this is a quote from the man page !!!
Therefore the values from the timestamp $t_1$ are transmitted as \lstinline{unsigned int}. \\

\textbf{Next event in micro seconds:} \\
If the master device initializes an event the time to the event is added to the \textit{update}. 
The value is calculated by the master device for every message new till the event, this is to give a security if one message is lost or not received by the slave. 
For this application a security factor of 3 had been chosen. The time is calculated in a way, 
that it is ensured that each device receives at regularly 3 messages before the event is started on all nodes in the system.
$$ Time to event = (intervalltime + max. trasmition delay) * security factor$$
The calculated value is broadcasted with the \textit{update} in microseconds as a unsigned integer.
Each slave subtracts it's own roundtrip delay from the time till the event and starts a internal countdown. \\

\textbf{Array of struct device:} \\
The information about the current average transmission delay of each slave is needed in each \textit{update}. 
The information is organized in a customized struct which was called device. This struct contains an IP and an transmission delay. 
The \textit{update} contains a array of this struct, in which the individual values for each device are stored. If an event is requested, each slave searches it's own IP
in the array after receiving the message. Each device subtracts it's own transmission delay form the time till the event. 
The maximum number of nodes within a group is restricted with the size of this array, this restriction was set to 64.\\

\textbf{The preload ID:} \\
Before a event can be started the content which is requested in sync must be loaded on each device. If a new event is requested each slave first gets a 
notification that it should load the requested content. This notification is implemented as an ID which is enhanced by "$1$" every time a new event is requested.
The slave compares the last processed preload ID with the current one and starts notifies the player to load the requested content, if they are not equal. \\

\textbf{Requested content:} \\
The name of the requested content had to be transmitted in the update as well.
This is implemented as a character array which holds the sync request and the filename of the content which should be synced next. 
If the slave receives a new preload request with the \textit{update} it forwards the request hold in this string to the player. \\ 

\textbf{Event ID:} \\
The event ID is similar to the preload ID, if the event ID in the \textit{update} is not equal to the last processed event ID the steps to initialize an event are taken. \\

The whole information of the package is collected in a packed struct before it is broadcasted. % if I need some more text I can here say what packed means and why !! 
The size of this whole structure is not bigger than 0.6 kB, which is a relative small package.

\subsubsection{Answer Package}

After the slave received an \textit{update} from a master it replies to it with the \textit{answer} package. 
The master receives this \textit{answer} and calculates as described above the transmission delay for the slave. Over the calculated values a moving average is
built for each slave. \\

\textbf{Group ID:} \\
The slave adds his own group ID to the \textit{answer} package. This information is important that a master does not process information from slaves which
are not in the same group. \\

\textbf{The seconds of $t_1$ and the micro seconds of the timespamp $t_1$:} \\
These two values are used as mentioned as message ID. They are received from the \textit{update} and copied to the \textit{answer}. 
The master device can use this value directly to calculate the roundtrip and transmission delay, after he received the \textit{answer}. \\

\textbf{Ready ID:} \\
If the slave received a prelaod request and it has notified the player, the player confirms after he has successfully loaded the requested content.
If this confirmation arrives the slave copies the ID of the current preload request in the ready ID value. The master can compare the ready ID from the slave 
to the current preload ID, if they are equal the master marks the slave as ready. If all slaves are ready the time till the event can be calculated and
the event can be initialized.
%hallo up (no quotes needed)

\subsection{Master Election}

After the application has started in the first step a master has to be defined. In the network all nodes are equal and similar to each other but each one
has a unique IP address. A master device has to be elected within the system. Therefore a master election had to be designed as part of the program. 
There were two ways implemented how a master can be found in the application. The first one is to set a device as master manually.
This can be done with an configuration option, which can be set by the user in the configuration file. 
The other implemented option to find a master in the network is
a dynamic election. The dynamic election is put to use if no master was specified in a system. \\

\textbf{The user specifies a master:} \\*
In the final program the user has the possibility to specify a master in the configuration file. To specify the master the correlating option has to be set in the configuration file. 
If this configuration option is set to true there will be no further dynamic election of any master in the system. 
If two masters would have been specified a conflict would arise. To prevent errors which could occur with two specified master only one master is allowed in a system. To make sure only one master exists at any time within the same system one master is discarded if there are more than one. 
To decide which master has to be terminated the IP addresses of the devices are compared.
The specified master with the higher IP continues as master and on the other device the application terminates and an error message is printed 
on the output screen for the user. The error message informs the user that only one master can be specified within the same group and asks the user to check
the configurations. \\

\textbf{Dynamic election of the master:} \\*
If no master was specified by the user the election of the master is dynamic and automatically by the program. 
When the master election was implemented all situations how devices can be added to the network had to be considered. 
The following scenarios where considered when designing the dynamic election: \\
\begin{itemize}
    \item only one device is in the system 
    \item a device gets added to a system with a already existing master
    \item the master device in the system is shut down
    \item a device which is specified as master gets added to a network with a dynamic elected master
    \item a slave device is reconfigured as master during the run time in the network 
    \item several devices are added to a system with no master at the exact same time, for example after a blackout
\end{itemize}

\subsubsection{Implementation of the Master Election}

The basic principle of the implemented master election is that a devices switches in master mode if no master is in the system. If two masters occur in the same
system the IP addresses of the two masters are compared and the device with happens to have the higher IP remains as only master. The master
election was designed that the already defined package types, which are necessary for the regular work mode, could be used. \\*

When the application is started the configuration file is read. If in the configuration option is set that the device should be the master, 
the program starts as master and a global variable \lstinline{b_force} is set to one. This variable is also included in the \textit{updates} which are broadcasted 
over the network. If the device was not specified as master the program starts in slave mode and listens for \textit{updates}. 
If a \textit{update} is received from a master with the same group ID an \textit{answer} package is sent. 
If no \textit{update} is received for a defined time period the device becomes a master. The time how long the slave waits for an \textit{update} is defined as
\lstinline{L_INT_WAITTIME}, and set in this application to 3 seconds. \\

The master and slave mode are implemented as functions which are called by  the main function, each mode contains a infinite loop from which is braked out 
if the stop signal is set. \\
The stop signal is set in the following situations:
\begin{itemize}
    \item the slave function does not receive an \textit{update}
    \item if a dynamic elected master received an \textit{update} from a specified master  
    \item if a specified master received an \textit{update} from a specified master with an higher IP
    \item if a dynamic elected master received an \textit{update} from a other dynamic elected master with an higher IP
\end{itemize}

\begin{figure}[h!]
    \centering
        \includegraphics[width=0.35\textwidth,keepaspectratio]{main}
        \caption{Visual description of the main routine}
\end{figure}

\newpage

Before the function returns all allocated memory is freed by a cleanup handler. In the main function the next mode/function is called after a mode returned. 
This is also implemented in a infinite loop so that a slave which became master can become a slave again. For example when a other master which was specified 
by the user is added to the system. Before the master function returns all threads which where called in the function are terminate and the in each thread the
allocated memory is freed and the \textit{mutex} variables which are hold currently by the thread are unlocked.
After all threads exited the function returns. If the master was a dynamic elected master he starts in slave mode, 
if the master was already a specified one a error message informs the user that two specified master are currently in the system and the application terminates.

\begin{figure}[h!]
    \centering
        \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{master-election}
        \caption{Visual description of the master election}
\end{figure}

\newpage

\subsection{Final Design of the Protocol}

In the following section the final design of the protocol was visualized with the help of a Message Sequence Chart. \\ 

\begin{multicols}{2}

\includegraphics[width=0.45\textwidth,trim = 0mm 20mm 0mm 0mm,clip,keepaspectratio]{workingmode1.png} \\ %\\

%hallo down (no quotes)
When the devices is added to a system it starts in slave mode. Here it can been seen that device B is in the 
begin the only device in the system. After some time the devices A, C and D are also switched on. In the
slave mode the application is waiting for an \textit{update} from a master. 

If no \textit{update} is received in the slave mode the device switches to the master mode. Here the device B switches
at first in the master mode, because it was started at first and the timeout for waiting for an \textit{update} is
already over on this device. In the master mode the device starts to broadcast \textit{update}s to each node in 
the network. The other devices stay in save mode because an \textit{update} was received. Each device pings back to
the master device.

When the device is taken off the network which was dynamically elected as master, no more \textit{updates} are broadcasted
over the network. In this case the device B is removed from the system. After no \textit{update} was received all the
remaining devices switch in the master mode. Here it can be seen that device A, C and D are now in the master mode.
After a master receives a master message it compares it's own IP to the one from the other master. If the own
IP is lower it switches back to slave mode again. In this example, device C and D turn into slaves again, A 
remains the master and continues broadcasting \textit{updates}.

If a devices is added to a network where there is already a master it just starts to \textit{answer} to the received
\textit{updates}. In this case device B is turned on again an is now a slave node.

If a slave node is taken off the network, it can't reply anymore to \textit{updates}. The master device deletes 
a slave device which is not responding for a period from it's intern list.

\end{multicols}

\newpage

\begin{multicols}{2}
\includegraphics[width=0.45\textwidth,keepaspectratio]{workingmode2.png} 
%\begin{center}
\caption{Figure: Message Sequence Chart} \\ \\ \\ 
%\end{center}

%\vspace*{1in}
If a device is added to a system where already a dynamically elected master exists, the specified master starts
to broadcast \textit{updates}, where the information that it is a forced master is contained in the \textit{update}. The other 
master reads this information, if it receives an \textit{update} from an master and switches in slave mode and starts to
respond to the new master. Also all the other devices start to respond to the new master.
\end{multicols}
%hallo up (no quotes)

It is shown how the final design of the protocol combines the regular work mode with the master election and how
the different package types are used. 
The step of visualizing the protocol with a MSC is an necessary and important step to design a application, as pointed out in \citep{MSC}. Through the visualizing conflicts which could occur are pointed out.
The purpose of a MSC (Message Sequence Chart) is to provide a language to specify  a communication behavior of system components 
and their environment. \\ %if I feel like it I can write more about MSC, just because I have such a nice source

With this design of the protocol, only two types of packages are needed and both the dynamical as the manual election of a master device is integrated in
the regular working mode.

\chapter{Implementation}

The application was implemented in the programing language C. 
This programming language has many advantages which are analyzed in \citep{adventagesC}. C is especially good for programming with limited resources, the language is very close to the machine and therefor specially suited for microcontrollers. 
With C the resource a device has can be used more efficiently. C is also the language which is currently most used to program UNIX systems, for example most of the GNU project is written in C. An main advantage of C is the speed of the resulting application. Code written in C can be optimized more than application which are written in other high level languages. 

%hallo down
\section{Communication - UTP}

For transmitting the so far described package the User Datagram Protocol was used.
The User Datagram Protocol (UTP) is a transport layer  protocol that rides on top of IPv4 or IPv6, that enables sending messages between devices over a network. 
The mechanism of UTP is described and showed by \citep[User Datagram Protocol]{UDP}.
UDP uses a very simple transmission model and provides only a minimal protocol mechanism. It does not provide any control mechanisms, therefore there is no guarantee 
of the delivery of the packages. There is also no guarantee for the order in which the messages arrive and also no duplicate protection.
UTP is used for application where error checking and correction is not necessary or done by the application, which uses it, itself.
If error checking is needed at the network interface level other protocols like the Transmission Control Protocol (TCP) or the Stream Control Transmission 
Protocol (SCTP) must be used. Tu sum it up, UDP is a low-overhead transport for applications that do not need guaranteed delivery like provided by TCP.
The advantages of UDP lies in it's simplicity, the simple operations of UTP make it fast and therefor ideal for delay-sensitive traffic.
Time-sensitive application could suffer from waiting for all the overhead that TCP requires to set up a connection between hosts before sending a message.
Also for time-sensitive application dropping packages is preferable to waiting for delayed messages. UTP is transaction-oriented which makes it most suitable for simple protocols. UTP is also stateless what allows a very large number of clients.
It is also suitable for broadcasting information. \\*

For this project one of the main advantage was the lack of delivery control mechanism and the resulting speed of the Protocol.
Therefore in the event synchronization application the communication between the devices is established with the User Datagram Protocol (UDP). 

\newpage

\subsection{Set up Connection}

In order for the application to be able to send and receive UTP packets an interface between the application and the network is necessary, this is 
provided by so called sockets. The principle and the use of sockets was described in \citep{socket1}.
The application creates the socket, where the socket type defines the communication typ. 
UTP for example uses \lstinline{SOCK_DGRAM} sockets. A socket is a bidirectional communication endpoint which can transmit or receive data from an other socket. \\

The necessary steps to set up a sockets for an UDP communication are shown in the \citep{socket}. The program code must contain the following steps:
\begin{itemize}
    \item Creating a socket/an endpoint for communication by calling \lstinline{socket()}
    \item Assining a address to the created socket by binding the socket with calling \lstinline{bind()} 
        and provide a \lstinline{struct sockaddr} in which the family and port are defined
\end{itemize}
    
When implementing a connection with UDP the device can be implemented as server or as client.
The communication accomplished with the above outlined commands is a bidirectional that means, both the sever and the client can 
send and receive packages. For the event synchronization the master function was implemented as server and the slave function is implanted as client.
The application is designed so that there is always one master and up to 64 slaves, therefore there is always one server and a variable number of clients
in the communication.

When transmitting packets with UTP the connection is not established before sending the message. The client for example sends a packet with 
\lstinline{sendto()} without connecting first to the server, when UTP is used the server also does not accept a connection, it immediately calls
\lstinline{recvfrom()} and waits for any data. The following graphic shows a model of server client communication.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.3\textwidth,keepaspectratio]{server-client.jpg}
        \caption{UTP concept}
\end{figure}

\newpage

When the socket should not be assigned to one particular address and instead watch out for all messages which are transmitted to this node over the network,
the member \lstinline{s_svadr.sin_addr.s_addr} must be set to \lstinline{INADDR_ANY}. A socket also can be bound to the broadcast address and that receives
all messages which are broadcasted over the network.

\subsubsection{Broadcast Messages}

For the application it is necessary not only to send packages between two devices, it is also needed to broadcast information. For example the \textit{updates} from
the master should be broadcasted. When messages are broadcasted, each device in the network receives the message without being addressed. To broadcast
messages over the network first the broadcast address needs to be calculated. 
Each device which uses the IP Protocol for communication needs a unique identifier, the so called IP address. With this identifier each device on the network can
be address individually. An IPv4 address is a 32-Bit value which contains to components the network ID and the host ID.

%here are quotes for the broadcast things ... look it up in the *.bbl !!!
The IPv4 Protocol which is used in this application uses a set of broadcast addresses to provide the above described one to 
everyone transmission. The network broadcast address can be calculated by setting all the bits of the Host ID part to "1", as outlined in \citep{broadcast}.
For getting the broadcast address of a network in a application the device performs a bitwise "and" operation over it's own IP address and 
mask where all the host-bits are set to 1. The graphic shows the operation how a broadcast address is formed.
% graphic form http://www.ehow.com/how_5175490_calculate-broadcast-address.html 

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.35\textwidth,keepaspectratio]{broadcast.jpg}
        \caption{Calculating broadcast address}
\end{figure}

% one more quote from the main page !!!
When messages are broadcasted, the socket has to be configured, after it was created and bound to the interface, to enable broadcasting. 
This can be done in the code with \lstinline{setsockopt(int sockfd, int level, int optname, const void * optval, socklen_t optlen);} what manipulate options for 
the socket referred to by the file descripter \lstinline{sockfd}, as described in
\citep{LINUX}. When manipulating the socket options, the level at which the option resides and the name of
the option must be specified, for this application the level had to be specified as \lstinline{SOL_SOCKET} and the name of the option which had to be set to one is 
\lstinline{SO_BROADCAST}.

% reuse address
An other socket option has to be set, that indicates that the addresses supplied in a \lstinline{bind()} call should allow reuse of local addresses.
This option is set with \lstinline{setsockopt()} and the name of the option is \lstinline{SO_REUSEADDR}. 

\section{Master Mode}

As long as a device is the master device the program loops in the master function. The master function has to perform the listed tasks:
\begin{itemize}
    \item periodically prepare and broadcast \textit{updates}
    \item receive and process response packages from the slaves
    \item calculate the moving average of the roundtrip delay for each slave device 
    \item check if all devices still active in the system or if one was taken off the network 
    \item communicate with the player
    \item initialize a event if necessary
\end{itemize}

\subsection{Threads}

The function for the master mode was implemented as a multi thread application.
% https://computing.llnl.gov/tutorials/pthreads/#Thread
A thread is a independent stream of instructions that can be scheduled to run as such by the operating system. % direct quote !!!
Multiple threads simplified can be seen as a lightweight versions of a  set of processes. 
A thread is a procedure that runs independently from the main routine and other threads.
If a program is implemented as a  multi thread program, it can be described as a number of procedures, which run simultaneously.
Each thread acts like its an individual program, with the expiation that all the threads work in the same memory space. 

%http://www.cs.cf.ac.uk/Dave/C/node29.html#SECTION002910000000000000000
Multi threading can have many benefits for a application, some of that are pointed out in \citep{threads}:
\begin{itemize}
    \item Improve the responsiveness, in a program in which activities not dependent on each other can be redesigned so that each activity is defined as a thread. 
    For example, the user of a multi threaded GUI does not have to wait for one activity to complete before starting another.
    \item Improve program structure, many programs are more efficiently structured as multiple independent units of execution instead of as a single thread. 
    Multi threaded programs can be more adaptive to variations in user demands than single threaded programs.
    \item Use fewer system resources, programs that use multiple processes need more resources, 
    because each process has a full address space and operating systems state. Creating a thread instead of a process saves time and space.

% form http://www.cs.iit.edu/~cs561/cs450/ChilkuriDineshThreads/dinesh's%20files/Advantages%20and%20disadvantages.html 

    \item Threads can share data and therefor they do not need interprocess communication, like it would be necessary if multiple process are used for the same task.

% from http://www.zdv.uni-mainz.de/cms-extern/DUS/progtool/dce31unx/develop/appdev/Appde153.htm

    \item Using threads improves the performance of a program, it raises the computation speed of the application.
    \item Multiple threads are most used in multiprocessor system but using threads can also improve application on single processor devices 
    by permitting the overlap of input and output or other slow operations.
\end{itemize} 

% http://www.albahari.info/threading/threading.pdf = nice source, but I haven't used it so far

To create a new thread the function (like described in \citep{LINUX})
\begin{lstlisting}
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                   void *(*start_routine) (void *), void *arg);
\end{lstlisting}
from the \lstinline{pthread.h} header has to be called. The new thread starts execution by invoking \lstinline{start_routine()}, 
\lstinline{void *arg} is passed as argument to the \lstinline{start_routine()}. \\*

If a thread is stared the function 
\begin{lstlisting}
int pthread_join(pthread_t thread, void **retval);
\end{lstlisting}
waits for the thread specified by \lstinline{thread} to terminate.

\subsubsection{Mutual Exclusion}

When using multiple threads and shared data it is necessary to ensure that at no time two processes access the data at the same time.
The section in the code in which the shared data is accessed in a thread is called critical section, this section must not be accessed by
two or more threads at the same time, as pointed out in \citep{mutex}. This is a basic problem in concurrent computing, to protect resources from parallel access, mutexes are used.
A \textit{mutex} is a mutual exclusion lock which can only be hold by one thread at a time.
%www.thinkingparallel.com/2006/09/09/mutual-exclusion-with-locks-an-introduction
One of the challenges in programming is to find all section in a code where shared data is accessed. It is really hard to debug a missing \textit{mutex}, 
because the error can not be reproduced that easily and the error may not occur for many runs. Therefore it is very important to comprehensively test programs where multiple threads access shared memory.
A \textit{mutex} variable can have to sates: locked/set and unlocked/reset. 
If a thread wants to access a shared memory the \lstinline{pthread_mutex_lock()} function
\begin{itemize}
    \item locks the \textit{mutex}, if it is currently unlocked
    \item blocks the calling thread, if the \textit{mutex} is already locked by an ohter tread, untill it is unlocked again
    \item might block forever, if the \textit{mutex} which was tired to be locked is already held by the current thread
\end{itemize}

If the tread finished the critical section the \lstinline{pthread_mutex_unlock()} function
\begin{itemize}
    \item unlocks the \textit{mutex}, if the \textit{mutex} was owned by the calling thread
    \item returns an error, if the \textit{mutex} is already unlocked
    \item unlocks the \textit{mutex} or returns an error, if the \textit{mutex} was locked by an other tread, the behavior in this case depends on the type of the \textit{mutex}.
\end{itemize} 
This functionality ensures that no thread can access a critical section in which shared memory is accessed which is currently processed by an other tread.

A \textit{mutex} is created by calling \lstinline{pthread mutex init()} if \lstinline{NULL} is passed as argument to the function, the \textit{mutex} will have the default 
attributes. The ID of the created \textit{mutex} is returend to the calling thread through the \textit{mutex} parameter. When a \textit{mutex} is not needed anymore it should be
destroyed with \lstinline{pthread_mutex_destroy()}.

\subsubsection{How it was Used}

The master-mode function call three threads, which run parallel the device stays in the master mode. 
Before these threads are stared the connection is set up and configured. Then the function itself only call the threads and waits for them to terminate. 
The threads terminate if the stop signal as described in point xx is set. If all threads have terminated the function returns.
Each thread has an infinite loop that does a certain task. The tasks from the master-mode has been split up in the following three threads: \\*

\textbf{Broadcast Thread:} \\*
This threads prepares the \textit{updates} and broadcasts them over the network. 
All information needed in the \textit{update} (look up point xx master-\textit{update}) has to be collected and copied in the message before the components get 
converted form host byte order to network byte order using the function \lstinline{htonl()}. After the message is ready the whole struct is sent. \\

\textbf{Receive Thread:} \\*
This threads waits for \textit{answers} from slave devices, if an \textit{answer} was received a time stamp is saved. In the next step the group IDs are compared and it is
checked if the message needs to be precessed any further. If the message is relevant to this master (matching group IDs), the transmission delay is calculated.
For each slave their individual results must be stored separately. To maintain all the active slaves and their transmission delays and the current average delay,
a double linked list is used. Each node of the list holds the IP of a slave and the last round trip delays and as well the current average roundtrip delay,
 which is calculated with a moving average window. This list makes it possible to store information for every slave and easily add or remove slaves from the system.
If a new value was calculated for a slave the value is stored in the correlating node and the average is built new, to also take the latest value into account. 
Also the time when the save responded the last time is saved. This is used to be able to delete slaves, which were taken of the network and 
didn't respond for a given time. \\
 
\textbf{Check Thread:} \\*
In this threads it is checked if all slaves which are currently observed by the master and kept in the list are still responding. If a slave is
not responding any more this treads deletes the node from the list. \\*

There is one more thread which is started in the main function and runs in the master and as well in the slave mode. This thread is 
communicating with the player and is necessary for the integration of the synchronization application in the existing system. 

If an event is requested and is ready to be initialized a thread which simply holds an countdown is stared. This is the same in the slave-mode.
This thread terminates after the countdown is over and the event has been initialized.

\subsection{Flow Chart}

To implementation of the master-mode function can be seen in the graphic on the next page. There can be seen all three threads and the steps in each thread.


\begin{landscape}
    \begin{figure}[h!]
        \includegraphics[height=\textheight,keepaspectratio]{master-mode.jpg}
        \caption{Flow Chart - Master Mode Function}
    \end{figure}
\end{landscape}

\section{Slave Mode}

If the device is currently in the slave state, the slave function has to perform the following tasks:
\begin{itemize}
    \item receive \textit{updates} and response to them
    \item communicate with the player
    \item initialize a event if necessary
\end{itemize}

All these tasks a performed in the function itself. In the slave mode the function \lstinline{recvfrom()} waits for an \textit{update} from a master. 
If an \textit{update} was received in the first step it is checked if the event ID has changed and if an event has to be initialized. If an event should be 
stared like in the master mode a thread with a countdown is stared which terminates after the event again. Then all the informations are added to 
the \textit{answer} and the \textit{answer} is sent to the master the \textit{update} was received from. Also the communication with the controller is done directly in the 
slave-mode function.

%\newpage

\subsection{Flow Chart}

In the following flow chart the steps which are performed in the slave-mode can be seen. \\
\begin{addmargin}{2cm}
        \includegraphics[width=0.45\textwidth,keepaspectratio]{slave-mode.jpg} \\
        \caption{Figure 5.1.: Flow Chart - Slave Mode Function}
\end{addmargin}

\section{Integration}

The problem solution also contained the integration of the event synchronization in the existing player, therefor the application had to communicate with
the player, therefore a pipe has been used. 

\subsection{Communication with a Pipe}

% quotes from http://www.gnu.org/software/libc/manual/html_node/Pipes-and-FIFOs.html
A pipe is a mechanism for interprocess communication, as described in \citep{pipe}. Data written to the pipe by one process can be read by another process. 
The data in a pipe is handled in a first-in, first-out (FIFO) order, therefore pipes are referred as FIFO in the further descriptions.
A FIFO has to be open at both ends, that means that it can only be written to a FIFO from which is read by a other precess, it also can be read
from a FIFO a other process is writing to.
% http://docs.oracle.com/cd/E19455-01/805-7478/6j71mbrdh/index.html
FIFOs only allow one way communication, that means that one end of a FIFO is used for writing data and the other for reading.
FIFOs are a tool that can be used for unidirectional communication between unrelated processes.
To create a FIFO the following commands can be used \lstinline{mknod()} or \lstinline{mkfifo()}. After a FIFO was created it must be opened by
the processes which should communicate.
They are opened in the same manner as other file system nodes with \lstinline{open()}. After the pipe is opened a process can ether write
\lstinline{write()} or read \lstinline{read()} from it.

% more particular
The player already communicates with other processes on the device over a FIFO. The pipe which is was used so far by other programs to 
give commands to the player is called the \lstinline{controller.fifo}, also this application uses that pipe to start the event. 
Because pipes only allow unidirectional communication, there was one pipe new created for the player to request events form the synchronization application. 
This pipe is read by the synchronization application and the player writes to it. In the first steps of the main function before the master or slave
function is called, it is check if the pipes need for the communication already exist and if not they are created.

% set of commands
If a content should be played in sync, the file has a flag set, which indicates this. When the player is playing content it always loads the next content 
while playing the current content. When the player loads a file and the file has the flag set, it writes a message in the pipe for the synchronization application, 
requesting an event (\lstinline{sync_req}. The synchronization program can deny the request, in this case a deny message is written in the controller pipe for 
the player (\lstinline{sync_deny}). The request is denied if the device is currently in the slave mode, if the request was denied the device continues playing
the next content which should not be played in sync. If the device is in the master mode, each device is notified that the form the master device requested 
sync content should be loaded. The request for loading the content is transmitted over the network with the \textit{update} and on each device the request is written to
the pipe for the player (\lstinline{sync_req}). If a device has finished loading the content, the player notifies the synchronization application 
(\lstinline{sync_rdy}) which adds the information to the \textit{answer} for the master. If all devices have successfully loaded the next content, the event is 
initialized by the master. Each device gives the signal to the player to start the content (\lstinline{sync_EVENT}).
Each slave has an internal countdown which cancels the event (\lstinline{sync_cancel}) if the event is not initialized after a request for loading a content, this is to prevent
errors if the master device is taken of the network after a request for loading was sent. \\*

The whole communication over the pipes is shown in the graphic below. \\
\begin{figure}
    \centering
        \includegraphics[width=\textwidth,keepaspectratio]{integration}
        \caption{Visual Description of the Integration}
\end{figure}

\subsection{Options for user}

The user has the possibility to set several configuration options for the time synchronization.
This options can be set in a configuration file. All the options are described below:

\textbf{sync\_enabled}: \\*
This option specifies if the time synchronization is active on the device. A script is run in the background on the device which checks the configuration files 
and starts programs or stops them if the configuration is changed. After the devices is booted the script reads the configuration files once and 
starts the programs.

\textbf{sync\_group\_id}: \\*
The devices within the same network can be grouped, this option is imported because different devices in the same network can also play different contend 
with the groups you can specify which devices in the network should be synced together if a synchronized event is requested. 
If this configuration option is set to -1 which is also the default configuration the synchronization application is not executed because the device would not sync to any other device.

\textbf{sync\_group\_order}: \\*
With the group order a order within the group can be defined. This can be useful if the devices should play different content synchronized. 
For example different screens which are ordered next to each other and where each display shows only a part of the same picture 
(or for example two robots which cooperate, each one does a different action but the event must be in perfect sync).

\textbf{sync\_forced\_master}: \\*
%here it would be nice to know why the user needs this option 
The synchronization application is implemented in as a master slave system. If this option is not set the master is selected dynamically, 
this devices becomes the master. If an dynamically selected master already exists the old master returns to slave mode. 

\textbf{sync\_wait}: \\*
Due to the time drift the played content gets out of sync, if contend should be played in sync and one device has not finished the other contend yet, 
there are two options. The default option is that the wait option is set. In this case the devices wait for each other and then start the synced content. 
This can cause the screen to show no content for a short period (usually not longer than 1 to 2 seconds) if this should be avoided the option can be set to false. 
In this case the device is playing some other content which must not be in sync, if all devices finished the old contend the new content will be interrupted. 
For this option also special content can be specified, for example pictures are a good option for this purpose.

\section{Conclusion and Prospect}

An application was designed and implemented which gave the company \textit{"Dension"} the requested possibility to 
synchronize events on their devices. The basic idea and the concept of the solution were based on a comprehensive analysis
in the subject area. The implementation of the program was finished and afterwards it was tested on representative networks. 
The accuracy which could be achieved in these networks with the application was in average
1 millisecond, which complied to the requirements. When an event is initialized in the current sate of the application the
player on the device is notified to start the requested content. The program can easily be adjusted for further other application, by
implementing an new sets of commands with which other processes as the player can be notified to do a task to a given time.

% yehhh an other thing were I have no idea what I should write 

% Literaturverzeichnis
\bibliography{Vorlage_BT_BMR_WS2013_Literatur}
\newpage

% Abbildungsverzeichnis und Tabellenverzeichnis
\begingroup
    \renewcommand*{\addvspace}[1]{}
    \phantomsection
    \addcontentsline{toc}{chapter}{\listfigurename}
    \listoffigures
    \newpage
    %\phantomsection
    %\addcontentsline{toc}{chapter}{\listtablename}
    %\listoftables
\endgroup


% If you use the document class "scrartcl" you need to use  \addsec{List of Abbreviations} instead of \addchap{List of Abbreviations}
\addchap{List of Abbreviations}
\hspace{-17mm}\begin{tabular}{>{\raggedleft}p{0.2\linewidth} p{0.75\linewidth} p{0.1\linewidth}}
www & World Wide Web \\
URL & Uniform Resource Locator \\
    UDP & User Datagram Protocol \\
NTP & Network Time Protocol \\
MSC & Message Sequence Chart
\end{tabular}

\begin{appendix}
\chapter[Source Code]{Source Code}

FILE: syncd.c
%\lstinputlisting[language=C]{syncd.c}

\end{appendix}

\end{document}
