% !!! A socket provides a bidirectional communication endpoint for sending and receiving data with another socket.


% !TEX encoding = IsoLatin2

% LaTeX Template Version 3.1,  JuLY 2011
% by Dr. Andreas Drauschke (andreas.drauschke@technikum-wien.at) and Dr. Susanne Teschl (susanne.teschl@technikum-wien.at)
% minor adaptations by Harald Stockinger (harald.stockinger@technikum-wien.at)
%
% Adaptions for MR done by M. Widrich (BMR6) in January 2012, tested by W. Kubinger in March 2012
%
% Fragen zu den BMR- und MMR-Vorlagen bitte an Wilfried Kubinger (kubinger@technikum-wien.at) richten.
%
% Angepasst an MMR4, SS2013: 27.2.2013, WK
%


\documentclass[a4paper,bibtotoc,oneside]{scrbook}
% For short papers the documentclass "scrartcl" is sufficient. In this case the highest sectioning structure is "section" ("chapter" does not exist).
% \documentclass[a4paper,bibtotoc,oneside]{scrartcl}

\usepackage{hyperref}

\usepackage[ansinew]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman,english]{babel}
\selectlanguage{english}
\usepackage{amsmath,amssymb,amsfonts,amstext}

\usepackage{fancyhdr}
\lfoot[\fancyplain{}{}]{\fancyplain{}{}}
\rfoot[\fancyplain{}{}]{\fancyplain{}{}}
\cfoot[\fancyplain{}{\footnotesize\thepage}]{\fancyplain{}{\footnotesize\thepage}}
\lhead[\fancyplain{}{\footnotesize\nouppercase\leftmark}]{\fancyplain{}{}}
\chead{}
\rhead[\fancyplain{}{}]{\fancyplain{}{\footnotesize\nouppercase\sc\leftmark}}

\usepackage{color}

\usepackage{listings} %package for code
\lstset{language=C, basicstyle=\footnotesize}

\usepackage{multicol} %columns

\usepackage{lscape} %make a page landscape

\usepackage{helvet}
\renewcommand{\familydefault}{cmss}

\usepackage[pdftex]{graphicx}

\usepackage{harvard}

\usepackage{array}

\setlength{\textheight}{225mm}
\setlength{\textwidth}{1.05\textwidth}

\DeclareGraphicsExtensions{.jpg, .png, .gif}

\tolerance = 9999
\sloppy

% Anpassung einiger "Uberschriften
\renewcommand\figurename{Figure}
\renewcommand\tablename{Table}

% Abbildungen, Gleichungen und Tabellen werden fortlaufend nummeriert
\renewcommand\thefigure{\arabic{figure}}
\renewcommand\thetable{\arabic{table}}
\renewcommand\theequation{\arabic{equation}}
\usepackage{remreset}
\makeatletter
  \@removefromreset{figure}{chapter}
  \@removefromreset{table}{chapter}
  \@removefromreset{equation}{chapter}
\makeatother

%Zum korrekten Formatieren von Verzeichnissen
\usepackage{tocloft}
\renewcommand{\cftfigpresnum}{Figure~}
\renewcommand{\cfttabpresnum}{Table~}
\renewcommand{\cftfigaftersnum}{:}
\renewcommand{\cfttabaftersnum}{:}
\setlength{\cftfignumwidth}{2.5cm}
\setlength{\cfttabnumwidth}{2.5cm}
\setlength{\cftfigindent}{0cm}
\setlength{\cfttabindent}{0cm}

\begin{document}

%Festlegen des Zitier-Standards
\bibliographystyle{HarvardFHTWMR_V1_2e}%Zitierstandard FH Technikum Wien, Studiengang Mechatronik/Robotik
\citationstyle{dcu}%Correct citation-style (Harvardand, ";" between citations, "," between author and year)
\citationmode{abbr}%use "et al." with first citation
    \newcommand{\citepic}[1]{(Source: \protect\cite{#1})}%Zitat: Bild
    \newcommand{\citefig}[2]{(Source: \protect\cite{#1}, p. #2)}%Zitat: Bild aus Dokument
    \newcommand{\citefigm}[2]{(Source: taken with modification from \protect\cite{#1}, p. #2)}%Zitat: modifiziertes Bild aus Dokument
    \newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
    \newcommand{\acessedthrough}{Available at:}%Für URL-Angabe
    \newcommand{\acessedthroughp}{Available through:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
    \newcommand{\acessedat}{Accessed}%Für URL-Datum-Angabe
    \newcommand{\singlepage}{p.}%Für Seitenangabe (einzelne Seite)
    \newcommand{\multiplepages}{pp.}%Für Seitenangabe (mehrere Seiten)
    \newcommand{\chapternr}{Ch.}%Für Kapitelangabe
    \renewcommand{\harvardand}{\&}%Harvardand in Zitaten
    \newcommand{\abstractonly}{Abstract only}
    \newcommand{\edition}{~edition}%Edition -> note, that you have to write "edition = {2nd},"!

\pagestyle{fancy}

% title page:
\thispagestyle{empty}
\begin{picture}(0,0)
\color{white}\sffamily
\put(-101,-749){\includegraphics[width=1.002\paperwidth, height=\paperheight]{BM_2011.pdf}}
\put(220,-670){\includegraphics[width=0.5\textwidth]{FHTW_Logo_4c.pdf}}
\put(-30, -20){\bfseries\huge BACHELOR'S PAPER}
% insert degree program:
\put(-30,-50){\Large Degree Program Mechatronic/Robotic}


\put(-32,-150){
\begin{minipage}{14cm}
\bfseries\huge
% insert title:
Event Synchronization for \\* Microcontroller in a Local Network
\end{minipage}
}
% insert author:
\put(-30,-250){\large By: Birgit Schreiber}
% insert student ID:
\put(-30,-270){\large Student Number: mr11b068}
% insert supervisor:
\put(-30,-310){\large Supervisor: Dipl. Ing. Dipl. Ing. Zoltan Puskas}
\put(-30,-350){\large Vienna, \today}
\color{black}
\end{picture}

\newpage

\section*{Declaration}\thispagestyle{empty}
I confirm that this paper is entirely my own work. All sources and quotations have been fully acknowledged in the appropriate places
with adequate footnotes and citations. Quotations have been properly acknowledged and marked with appropriate punctuation.
The works consulted are listed in the bibliography. This paper has not been submitted to another examination panel in the same or a
similar form, and has not been published. I declare that the present paper is identical to the version uploaded.
\\[5\baselineskip]
\rule{5cm}{0.2pt}\hfill\rule{5cm}{0.2pt}\\
\phantom{Datum }Place, Date\hfill Signature\hspace{15mm}

\newpage

% German abstract:
% \section*{Kurzfassung}\thispagestyle{empty}
% Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text ...
% \\ \vfill
% Please insert 3-5 German keywords that characterize the thesis:
% \paragraph*{Schlagw{\"o}rter:} Schlagwort 1, Schlagwort 2, Schlagwort 3, Schlagwort 4, Schlagwort 5

\newpage

% English abstract:
\section*{Abstract}\thispagestyle{empty}
Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text Text ...
\\ \vfill
% Please insert 3-5 English keywords that characterize the thesis:
\paragraph*{Keywords:} time, synchronization, micro controller, network, package 
 
\newpage

% Acknowledgments = complete
\section*{Acknowledgments}
\thispagestyle{empty}
First I would like to thank the company "Dension" for giving me the opportunity to do an internship. The internship woke my interest for software development
and digital science. 
I also want to thank IAESTE-Budapest for organizing my accommodation and all the great spare time activities. It was a great experience, to do an internship
in a foreign country and experience a different culture.
Especially I want to thank my mentor and supervisor Zoltan Puskas, who took a lot of time and effort to supervise me during my internship. 

\newpage
\tableofcontents\thispagestyle{empty}

\newpage
\setcounter{page}{1}

% Introduction 
\chapter{Introduction}

This thesis is a report about a project which was carried out during an internship at the company "Dension" in Budapest. 
This internship was part of the B.Sc. program Mechanics/Robotics at the university of applied science \textit{Technikum Wien}. 
The company "Dension" is an automotive electronic company which sells micro controllers which are used for different purposes, for example 
they are used as multimedia gateways in cars or other multimedia purposes.
These micro controllers are also used for showing videos and playing audio content on screens in shopping centers for example.
During my internship I worked in the development department of the company. I got an good insight into software development for micro controllers with 
limited resources and in UNIX based operation systems.

The topic of the thesis \textit{"event synchronization for micro controller"} was a feature which was requested from costumers. 
This topic was given to me because synchronization of digital devices is a common problem in computer science and as well in robotic, so I could
profit a lot form it. 

% Subject Area
\section{Subject Area - Synchronization in Digital Science}

Synchronization is a common problem in computer science and engineering. The internal clocks of computers and micro controllers are not very accurate,
 because even if the clocks are started with the same time value after some time all clocks differ due to cock drift. 
This drift is caused by different rates of the clocks with which the internal time is counted. 
The synchronization of digital devices is a problem which occurs in many technical applications. 
There are several problems which are caused by the fact that clocks on different devices are not in sync, specially in distributed systems 
which should fulfill a shared task. One example for the synchronization problem in robotic is, when it is needed to identify causal relationships
between events in the physical world, from sensors in different locations.

% Problem Description
\section{Problem Description}

The microcontroller which are produced and distributed by the company work on a UNIX based operating system which is specially designed 
for their purpose and applications. These microcontroller have very limited resources, like processing power and RAM. 
The company offers different models, the most sold model is the MPX.
The MPX has the following specifications:
\begin{itemize}
    \item Kernel: Linux (32 Bit)
    \item CPU: 720 MHz
    \item RAM: 256MB@360MHz
    \item Flash 1MB to 8MB
    \item 32MB @ SD-Card 
\end{itemize}
The company got the request form several of their customers that they would like to synchronize events on devices which are connected in a local network. 
This feature was requested for example to start videos in sync on monitors which are accessed by different microcontroller. 
So the company searched for a possibility to meet the needs of the costumer and synchronize different devices. 
When searching a solution it had to be consider the resources available 
on the devises are limited and that the other functionalities must not be constrained. Playing video and audio can take a lot of processing power, 
tests showed that playing a video and an audio content at the same time could take up to 90\% of the CPU power on the MPX. 
This had to be taken in account, because the synchronization should not lower the quality of the video and audio content.
It was also an important point that that the synchronization got integrated in the existing player.
An other specification which arose through the request
from the customers was that there will be no internet connection in most situations.

In conclusion the task was to design, implement and test an application, which should give the possibility to synchronize an event on the companies
devices.

% State of the Art
\section{State of the Art}

There are already several solution for the synchronization problem. In the first step a research on existing solution was done.
The implementation and algorithm of these solutions were analyzed. On basis of this knowledge it was considered which parts of existing solution 
could be used and what had to be implemented to find a optimal solution for the given problem. 

\subsection{Existing synchronization solutions}

A common solution for the synchronization problem is the Network Time Protocol (NTP). It is a networking protocol to synchronize clocks on 
devices which are connected over a network. NTP is mainly used to synchronize computers over the Internet to high-precision timekeeping devices like atomic clocks.
These clocks are capable of measuring the time very accurate and are used as reference. 
Implementations of NTP transmit timestamps via the User Datagram Protocol (UDP) to the devices which should be adjusted. 
Than the clock on the device is set to the correct value or the clock rate is fastened or slowed down, 
till an accurate time is reached. If the clock is adjusted by fastening or slowing the clock rate, it takes some time till the device has the correct time on
the internal clock.

For the given task simply setting up an implementation of NTP was not an satisfying option for several reasons.
From the task description it was clear that a connection to the internet will not be provided in most of the application cases. Also the fact that
NTP adjusts the internal clock on the device was a reason why it was not considered as a optimal solution for the given task, because the clocks on
the devices, which should be synchronized, had in most cases very different rates and the clock drift
 would have been huge again within a short period. Also a continuous synchronization was not necessary for the given task. 
A further point which had to be taken into account when considering different solutions was that it was very important for the company, 
that the synchronization could be fully integrated in the already existing system with as less alterations of the existing structures as possible.
Also other established time sync solutions like SNTP and PTP where considered but in conclusion for the given task they had the same weaknesses as NTP. 

All considerations of the above described facts led to the decision to design and implement a new simple protocol.
The new algorithm had to have the benefits of NTP and had to be suitable for the task and take the integration in the already existing programs and structures 
in account. In summery the resulting task was to designed a protocol which had the for the task relevant benefits of the algorithm used in NTP and which
enabled a integration in the existing programs. For that reason the way NTP works and how it is implemented was analyzed.

\subsubsection{NTP - Network Time Protocol} % If I need page filler I can write more here !!

In NTP implementations packets for high prison clocks are transmitted via the internet to the nodes in a network. 
To take the transmission delay of the network and the variance in transmission delays in account, 
the delay form several runs is calculated and averaged with a modified version of \textit{"Marzullo's algorithm"}.
The transmission delay is the time which is needed till the message from the instance with the accurate clock is deliver to the device which should be adjusted.
The transmission delay can not be measured directly because the internal clocks of the two instances have different times and there is always an offset. 
To be able to determine the transmission delay the round trip delay is measured. 
To measure the round trip delay a package is delivered from the first instance to the target device
and than the target device answerers to the first instance, the time from sending the first message till receiving the \textit{answer} is called the round trip delay.
Every time when a packet is sent or received timestamps are saved, from these timestamps the round trip delay and the offset can be calculated. \\* \\*
The round trip delay $\delta$ is calculated: 
$$\delta=(t_3-t_0)-(t_2-t_1)$$ \\*
The offset $\Theta$ is calculated:
$$\Theta=\frac{(t_1-t_0)+(t_2-t_3)}{2}$$ \\*
where\\*
$t_0$ is the timestamp when the packet is sent\\*
$t_1$ is the timestamp when the packet is received from the device\\*
$t_2$ is the timestamp when the response packet is sent from the device\\*
$t_3$ is the timestamp of the response packet reception.\\*
With the knowledge of this tow values the clock frequency is adjusted to reduce the offset.

\chapter{General Design of the Solution}
 
For the solution of the given problem a simple protocol was designed with a master/slave configuration where packages were transmitted
over a local network. In the designed application the master had unidirectional control over the slave devices. 
The master saved timestamps when a package was sent or received, from these timestamps the round trip delay was calculated for each device in the system. 

\section{Protocol}

In the regular working mode the master device broadcasted frequently packages to all devices in the network. These packages will be referred as \textit{"updates"} 
in the further description, because the master always updated the current round trip delay of the slave devices with each sent package. 
All devices in the slave mode were waiting for \textit{updates} from a master. If an \textit{update} was received the slave answered to the master immediately with a 
package which will be referred as \textit{"answer"} from now on. The master device saved a timestamp every time it broadcasted or received a message. 
If the master received an answer package form a slave it calculated the round trip  delay $\delta$ and the transmission delay with the formulas:
$$\delta=(t_4-t_1)$$
$$\delta/2=(t_4-t_1)/2$$
These are simplified formulas of ones used in most NTP implementations. The formulas could be simplified because tests showed that on these 
devices in a representative network the time span $(t_2-t_3)$ was up to 10 times smaller than the average variation in the transmission delay. 
This time span got even smaller if no timestamps had to be taken on the slave device, the slave device simply pings back to the master device.
If a synchronized event was requested the master devices broadcasted this information within the \textit{update} and each slave was able initialize the event 
according to it's individual transmission delay .

\subsection{Packages}

There were two different types of packages designed which had been transmitted over the network. 
The package which was broadcasted by the master, the \textit{update,} and the \textit{answer} which
was sent back to the master by the slave. Each package contained different information and based on this the message type could be identified from the 
receiving device.

\subsubsection{Update Package}

The update packages contained the below described information. These data were broadcasted over the network periodically. \\

\textbf{Group ID:} \\
Within a network the devices could be grouped. This was a useful feature if there were device groups where each group should play different content but the
content within the group needed to be played in sync. In the configuration file there was an option for the user, to set a group ID for each device. 
Within each group a master was elected who calculated the round trip delay for each slave within the same group. 
If a device received a package from an device which was not in the same group
the message was not processed any further. The group ID of the master was transmitted in the \textit{update}. 
The first step a slave device did after receiving an \textit{update}  was
comparing the group ID from the sending master device to the own group ID. If the group IDs were not matching the received message was not processed any further. \\

\textbf{Force:} \\
It was possible to specify a device as master in the configuration file. If this option was set by the user a flag was set to one otherwise it remained zero.
This vale was not relevant for slaves, but if a master received an \textit{update} from an other master within the same group this parameter was important.
How this parameter was processed is described in detail at the chapter \textit{master election}. This parameter was important to avoid conflicts when more than
one master occurred in a system. \\

\textbf{The seconds of $t_1$ and the micro seconds of the timespamp $t_1$:} \\
Immediately before the \textit{update} is broadcasted a timestamp is taken. The values of the timestamp was transmitted in the \textit{update} as message ID. 
This message ID was sent back in the \textit{answer} from the slave. For taking the timestamp the function \lstinline{gettimeofday()} was used.
This function returned the type \lstinline{struct timeval}. The members of the struct \lstinline{tv_sec} and \lstinline{tv_usec} are of the type \lstinline{long int}. 
The size of a long int depends of the architecture of the device. The type \lstinline{int} or \lstinline{unsigned int} has the same size independent from the
architecture. Therefore the values had to be converted before they could be sent over the network. The type \lstinline{int} has the same size on all architectures, 
but each value also has to be converted from host byte order to network byte order before it could be transmitted.
% here a sentence why ... not architecture dependent, OS dependent
The \lstinline{htonl()} function converts the unsigned integer \lstinline{hostlong} from host byte order to network byte order. %this is a quote from the man page !!!
Therefore the values from the timestamp $t_1$ are transmitted as \lstinline{unsigned int}. \\

\textbf{Next event in micro seconds:} \\
If the master device initialized an event the time to the event was added to the \textit{update.} 
The value was calculated by the master for every message new until the event. This was implemented like this to give a security if one message was lost or 
not received by one slave. 
For this application a security factor of 3 had been chosen. The time is calculated in a way, 
that it is ensured that each device received regularly 3 messages before the event is started on all nodes in the system.
$$ Time to event = (intervalltime + max. trasmition delay) * security factor$$
The calculated value is broadcasted with the \textit{update} in microseconds as a unsigned integer.
Each slave subtracted it's own round trip delay from the time till the event and started a internal countdown. \\

\textbf{Array of struct device:} \\
The information about the average transmission delay of each slave was needed in each \textit{update}. 
The information was organized in a customized structure which was called \textit{device}. This struct contained an IP and the transmission delay. 
The \textit{update} contained an array of this struct, in which the individual values for each device were stored. If an event was requested, 
each slave searched it's own IP address
in the array after receiving the message. Each device subtracted it's own transmission delay form the time till the event. 
The maximum number of nodes within a group was restricted with the size of this array, this restriction was set to 64.\\

\textbf{The preload ID:} \\
Before an event can be started the content which was requested in sync must be loaded on each device. If a new event is requested each slave first got a 
notification that it should load the requested content. This notification was implemented as a ID which is enhanced by one every time a new event is requested.
The slaves compared the last processed \textit{load ID} with the current one and notified the player to load the requested content, if they were not equal. \\

\textbf{Requested content:} \\
The name of the requested content had to be transmitted as well in the \textit{update}. It was implemented as an character array which holds the 
sync request and the filename of the content which should be synchronized next. 
If the slave received a new request for loading a content with the \textit{update} it forwarded the request to the player. \\ 

\textbf{Event ID:} \\
The event ID was implemented similar to the \textit{load ID}, if the event ID in the \textit{update} is not equal to the last processed event ID the steps 
to initialize an event were taken. \\

The whole information of the package was collected in a packed struct before it could be broadcasted. 
% if I need some more text I can here say what packed means and why !! 
The size of this whole structure was not bigger than 0.6 kB, which is a relative small package.

\subsubsection{Answer Package}

After the slave received an \textit{update} from a master it replied to it with the answer package. 
The master received this \textit{answer} and calculated as described above the transmission delay for the slave. Over the calculated values a moving average was 
built for each slave. \\

\textbf{Group ID:} \\
The slave added his own group ID to the \textit{answer}. This information was important that a master did not process information from slaves which
were not in the same group. \\

\textbf{The seconds of $t_1$ and the micro seconds of the timespamp $t_1$:} \\
These two values were used as mentioned as message ID. They were received from the \textit{update} and copied to the \textit{answer}. 
The master device could use this value directly to calculate the round trip and transmission delay, after he received the \textit{answer}. \\

\textbf{Ready ID:} \\
If the slave received a load request and it had notified the player, the player confirmed after he has successfully loaded the requested content.
If this confirmation arrived the slave copied the ID of the current load request in the \textit{ready ID}-value. The master could compare the 
\textit{ready ID} from the slave 
to the current \textit{load ID}, if they were equal the master marked the slave as ready. If all slaves have sent their ready the time till the event was calculated 
and the event was initialized.

\subsection{Master Election}

After the application started in the first step a master had to be found. In a network all nodes are equal and similar to each other but each one
has a unique IP address. A master device had to be elected within this system. Therefore a master election had to be designed as part of the application. 
There were two ways considered how a master could be found. The first one was to set a device as the master manually. 
This was done with an configuration option, which could be set by the user in the configuration file. The other way to find a master in the network was 
a dynamic election. The dynamic election was put to use if no master was specified manually in the system. \\

\textbf{The user specified a master:} \\*
The user had the possibility to specify a master in the configuration file. To specify a master the correlating option had to be set.
If this configuration option had been set there was no further dynamic election executed. 
If two master had been specified a conflict would have occurred. To prevent errors which would have arose with two specified master, only one master was 
allowed in a system. 
To ensure only one master existed at any time within the same group, one of the masters were discarded if there were more than one. 
Which master had to be terminated was decided by comparing the IP addresses of the devices.
The specified master which had the higher IP address remained as master. On the other device the application terminated and an error message was printed 
on the output screen for the user. The error message informed the user that only one master was allowed to be specified within the same group. \\

\textbf{Dynamic election of the master:} \\*
If no master had been specified by the user the election of the master was dynamic and automatically executed by the program. 
When the master election was implemented all situations how devices could be added to the network had to be considered. 
The following scenarios where considered when designing the dynamic election: \\
\begin{itemize}
    \item only one device was in the system 
    \item a device got added to a system with a already existing master
    \item the master device in the system was shut down
    \item a device which was specified as master got added to a network with a dynamic elected master
    \item a slave device was reconfigured as master during the run time 
    \item several devices were added to a system with no master at the exact same time, for example after a blackout
\end{itemize}

\subsubsection{Implementation of the Master Election}

The basic principle for the master election was that a devices switched in master mode if no master was in the system. If two masters occurred in the same
group the IP addresses of the two masters were compared and the device with happened to have the higher IP remained as the only master. The master
election was designed that the already defined package types, which were necessary for the regular work mode, could be used. \\*

When the application was started as first step the configuration file was read. If configuration option was set that the device should be the master, 
the program started as master and the global variable \lstinline{b_force} was set to one. This variable was also included in the \textit{updates} which are broadcasted 
over the network. If the device was not specified as master the program started in slave mode and listened for \textit{updates}. 
If an \textit{update} was received from a master with the same group ID an answer package was sent by the slave node.  
If no \textit{update} was received for a defined period of time the device became the master itself. The time how long the slave waited for an \textit{update} was defined as
\lstinline{L_INT_WAITTIME}, and set in this application to 2 seconds. \\

The master and slave mode were implemented as functions which were called by the main function, each mode contained a infinite loop from which was braked out 
if the stop signal was set. \\
The stop signal was set in the following situations:
\begin{itemize}
    \item the slave function did not receive an \textit{update}
    \item if a dynamic elected master received an \textit{update} from a specified master  
    \item if a specified master received an update from a specified master with a higher IP
    \item if a dynamic elected master received an \textit{update} from a other dynamic elected master with a higher IP
\end{itemize}

\begin{center}
\includegraphics[width=0.35\textwidth,keepaspectratio]{main}
\end{center}

Before the function returned all allocated memory had to be freed by a cleanup handler. In the main function the next function was called after the other
function returned. With this it was possible to switch between the master and slave mode in the application
This was implemented in a infinite loop so that a slave which had become a master could become a slave again. For example when a other master which had been specified 
by the user was added to the system. Before the master function returned all threads which were called in the function had to be terminated. In each thread the
allocated memory was freed and the \textit{mutex} variables which were hold currently by the thread were unlocked.
After all threads exited the function returned. If the master was a dynamic elected master he started in slave mode, 
if the master was already a specified one an error message informed the user that two specified master were currently in the system, and the application terminates.

\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{master-election}

\subsection{Final Design of the Protocol}

In the following section it is shown how the final design of the protocol combined the regular work mode with the master election and how
the different messages were used. Therefore the protocol was visualized with a Message Sequence Chart (MSC). 
The purpose of a MSC  is to provide a language to specify and describe the communication behavior of system components 
and their environment by means of message interchange. % direct wiki quote !!!
To visualize the protocol with a MSC was also an necessary and important step to design the application, because through the visualizing conflicts
which could have occurred were pointed out.

\newpage

\begin{multicols}{2}

\includegraphics[width=0.45\textwidth,trim = 0mm 20mm 0mm 0mm,clip,keepaspectratio]{workingmode1.png} \\ \\

When a device was added to a system it started in slave mode. Here it can been seen that device B was in the 
begin the only device in the system. After some time the devices A, C and D were also switched on. In the
slave mode the application was waiting for an \textit{update} from a master. 

If no \textit{update} was received in the slave mode the device switched to master mode. Here the device B switched
at first in the master mode, because it was started at first and the timeout for waiting for an \textit{update} was 
already over on this device. In the master mode the device started to broadcast \textit{updates} to each node in 
the network. The other devices stayed in save mode because \textit{updates} were received. Each node pinged back to
the master.

When the dynamically elected master device was taken off the network, no more \textit{updates} were broadcasted
over the network. In this case the device B was removed from the system. After no \textit{updates} were received all the
remaining devices switched in the master mode. Here it can be seen that device A, C and D changed to the master mode.
After a master received an \textit{update} it compared it's own IP address to the one from the other master. If the own
IP address was lower it switched back to slave mode. In this example, device C and D turned into slaves again, A 
remained the master and continued broadcasting \textit{updates}.

If a devices was added to a group where there was already a master selected it just started to \textit{answer} to the received
\textit{updates}. In this case device B was turned on again an stared as a slave node.

If a slave node was taken off the network, it could not reply anymore to \textit{updates}. The master device deleted 
a slave device which was not responding for a period from it's internal list.

\end{multicols}

\newpage

\begin{multicols}{2}
\includegraphics[width=0.45\textwidth,keepaspectratio]{workingmode2.png} \\ \\ \\

If a specified master was added to a system where already a dynamically elected master existed, the device started
to broadcast \textit{updates}, where the information that it was a forced master is contained. The other 
master got this information, if it received an \textit{update} and switched to slave mode and started to
respond to the new master. Also all the other devices started to respond to the new master.
\end{multicols}

With this design of the protocol only two types of packages were needed and both the dynamical as the manual election of a master device was integrated in
the regular working mode.

\chapter{Implementation}

% quotes from adventagesC 
The application was implemented in the programing language C. C is especially good for programming with limited resources, the language is very close
to the machine and therefor specially suited for microcontroller. With C every resource a computer offers can be used. C is also the language which is currently most 
used to program UNIX systems, for example most of the GNU project is written in C. Also an other main advantage of C is the speed of the resulting application, C
code can be optimized much more than higher-level languages and the language set is very efficient. % !!!direct quote wiki.answers.com/Q/What_is_the_advantage_of
%_c_language. 
C is a very powerful programming language, it is best used for data structures and designing system software. % !!!direct quote iimchyderabad.com/Material/cnotes.pdf

\section{Communication UTP}

% all qutes from the Illustrated network 
The so far described package were transmitted with the User Datagram Protocol.
The User Datagram Protocol (UTP) is a transport layer  protocol that rides on top of IPv4 or IPv6, that enables sending messages between devices over a network.
UDP uses a very simple transmission model and provides only a minimal protocol mechanism. It does not provide any control mechanisms, therefore there is no guarantee 
of the delivery of the packages. There is also no guarantee for the order in which the messages arrive and also no duplicate protection.
UTP is used for application where error checking and correction is not necessary or done by the application itself.
If error checking is needed at the network interface level other protocols like the Transmission Control Protocol (TCP) or the Stream Control Transmission 
Protocol (SCTP) must be used. To sum it up, UDP is a low-overhead transport for applications that do not need guaranteed delivery like provided by TCP.
The advantages of UDP lies in it's simplicity, the simple operations of UTP make it fast and therefor ideal for delay-sensitive traffic.
Time-sensitive application could suffer from waiting for all the overhead that TCP requires to set up a connection between hosts before sending a message.
Also for time-sensitive application dropping packages is preferable to waiting for delayed messages.
UTP is transaction-oriented which makes it most suitable for simple protocols. UTP is also stateless what allows a very large number of clients.
It is also suitable for broadcasting information.

For this project one of the main advantage was the lack of delivery control mechanism and the resulting speed of the Protocol.
Therefore in the event synchronization application the communication between the devices was established with the User Datagram Protocol. 

\subsection{Set up the Connection}

In order for the application to be able to send and receive UTP packets an interface between the application and the network is necessary, this is 
provided by so called sockets. The application creates a socket, where the socket type defines the communication type. 
UTP for example uses \lstinline{SOCK_DGRAM} sockets. A socket is a bidirectional communication endpoint which can transmit or receive data from an other socket. \\

To set up a sockets for communication the following steps must be performed in the code:
\begin{itemize}
    \item Creating a socket/an endpoint for communication by calling \lstinline{socket()}
    \item Assigning a address to the created socket by binding the socket with calling \lstinline{bind()} 
        and provide a \lstinline{struct sockaddr} in which the family and port are defined
\end{itemize}
    
When implementing a connection with UDP the device can be implemented as server or as client.
The communication accomplished with the above outlined commands is a bidirectional that means, both the sever and the client can 
send and receive packages. For the event synchronization the master function was implemented as server and the slave function was implanted as client.
The application was designed so that there was at least one master in the system and up to 64 slaves, therefore there is always one server and a 
variable number of clients in the communication.

When transmitting packets with UTP the connection is not established before sending the message. The client for example sends a packet with 
\lstinline{sendto()} without connecting first to the server, when UTP is used the server also does not accept a connection, it immediately calls
\lstinline{recvfrom()} and waits for any data. The following graphic shows a model of server client communication.

\begin{center}
\includegraphics[width=0.3\textwidth,keepaspectratio]{server-client.jpg}
\end{center}

When the socket should not be assigned to one particular address and instead watch out for all messages which are transmitted to this node over the network,
the member \lstinline{s_svadr.sin_addr.s_addr} must be set to \lstinline{INADDR_ANY}. A socket also can be bound to the broadcast address and that receives
all messages which are broadcasted over the network.

\subsubsection{Broadcast Messages}

For the application it was necessary not only to send packages between two devices, also the possibility to broadcast information was needed. 
For example the \textit{updates} from the master were broadcasted. 

When messages are broadcasted, each device in the network receives the message without being addressed. To broadcast
messages over the network first the broadcast address needs to be calculated. 
Each device which uses the IP Protocol for communication needs a unique identifier, the so called IP address. With this identifier each device on the network can
be address individually. An IPv4 address is a 32-Bit value which contains to components the network ID and the host ID.

%here are quotes for the broadcast things ... look it up in the *.bbl !!!
%if I really need something to fill the pages I can explain the concept in detail with all the human readable aspects and blahhhhhhh
The IPv4 Protocol which was used in the synchronisation application uses a set of broadcast addresses to provide the above described, one to 
everyone, transmission. The network broadcast address is calculated by setting all the bits of the Host ID part to one.
For getting the broadcast address of a network in a application the device has to performs a bitwise \textit{"and"} operation over it's own IP address and a
mask where all the host-bits are set to 1. The graphic shows the operation how a broadcast address is formed.
% graphic form http://www.ehow.com/how_5175490_calculate-broadcast-address.html %it is a complete useless graphic but I need something to fill pages !!!

\begin{center}
\includegraphics[width=0.35\textwidth,keepaspectratio]{broadcast.jpg}
\end{center}

% one more quote from the main page !!!
When messages are broadcasted, the socket has to be configured, after it was created and bound to the interface, to enable broadcasting. 
This can be done in the code with \lstinline{setsockopt(int sockfd, int level, int optname, const void * optval, socklen_t optlen);} what manipulates options for 
the socket referred to by the file descripter \lstinline{sockfd}. When manipulating the socket options, the level at which the option resides and the name of
the option must be specified. For the synchronization the level was specified as \lstinline{SOL_SOCKET} and the name of the option which was set to one was 
\lstinline{SO_BROADCAST}.

% reuse address
An other socket option was set, that indicates that the addresses supplied in the \lstinline{bind()} call should allow reuse of local addresses.
This option was set with \lstinline{setsockopt()} and the name of the option was \lstinline{SO_REUSEADDR}. 

\section{Master Mode}

As long as a device was the master device the program looped in the master function. The master function had to perform the listed tasks:
\begin{itemize}
    \item periodically prepare and broadcast \textit{updates}
    \item receive and process response packages from the slaves
    \item calculate the moving average of the round trip delay for each slave device 
    \item check if all devices were still active in the system or if one was taken off the network 
    \item communicate with the player
    \item initialize a event if requested 
\end{itemize}

\subsection{Threads}

The function for the master mode was implemented as a multi thread application.
% https://computing.llnl.gov/tutorials/pthreads/#Thread
A thread is a independent stream of instructions that can be scheduled to run as such by the operating system. % direct quote !!!
Multiple threads simplified can be seen as a lightweight versions of a  set of processes. 
A thread is a procedure that runs independently from the main routine and other threads.
If a program is implemented as a  multi thread program, it can be described as a number of procedures, which run simultaneously.
Each thread acts like its an individual program, with the expiation that all the threads work in the same memory space. 

%http://www.cs.cf.ac.uk/Dave/C/node29.html#SECTION002910000000000000000
Multi threading can have many benefits for a application, some of that are pointed out at "Quelle":
\begin{itemize}
    \item Improve the responsiveness, in a program in which activities not dependent on each other can be redesigned so that each activity is defined as a thread. 
    For example, the user of a multi threaded GUI does not have to wait for one activity to complete before starting another.
    \item Improve program structure, many programs are more efficiently structured as multiple independent units of execution instead of as a single thread. 
    Multi threaded programs can be more adaptive to variations in user demands than single threaded programs.
    \item Use fewer system resources, programs that use multiple processes need more resources, 
    because each process has a full address space and operating systems state. Creating a thread instead of a process saves time and space.
% form http://www.cs.iit.edu/~cs561/cs450/ChilkuriDineshThreads/dinesh's%20files/Advantages%20and%20disadvantages.html 
    \item Threads can share data and therefor they do not need interprocess communication, like it would be necessary if multiple process are used for the same task.
% from http://www.zdv.uni-mainz.de/cms-extern/DUS/progtool/dce31unx/develop/appdev/Appde153.htm
    \item Using threads improves the performance of a program, it raises the computation speed of the application.
    \item Multiple threads are most used in multiprocessor system but using threads can also improve application on single processor devices 
    by permitting the overlap of input and output or other slow operations.
\end{itemize} 

% http://www.albahari.info/threading/threading.pdf = nice source, but I haven't used it so far
To create a new thread the function % quotes from the main page !!!
\begin{lstlisting}
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
                   void *(*start_routine) (void *), void *arg);
\end{lstlisting}
from the \lstinline{pthread.h} header has to be called. The new thread starts execution by invoking \lstinline{start_routine()}, 
\lstinline{void *arg} is passed as argument to the \lstinline{start_routine()}. \\*

If a thread is stared the function 
\begin{lstlisting}
int pthread_join(pthread_t thread, void **retval);
\end{lstlisting}
waits for the thread specified by \lstinline{thread} to terminate.

\subsubsection{Mutual Exclusion}

When using multiple threads and shared data, it is necessary to ensure that at no time two processes access the data at the same time.
The section in the code in which the shared data is accessed in a thread is called critical section, this section must not be accessed by
% publib.boulder.ibm.com/infocenter/aix/v7r1/index.jsp?topic=%Fcom.ibm.aix.genprogc%2Fdoc%2Fgenproc%2Fmutexes.html
two or more threads at the same time. This is a basic problem in concurrent computing, to protect resources from parallel access, \textit{mutexes} are used.
A \textit{mutex} is a mutual exclusion lock which can only be hold by one thread at a time.
%www.thinkingparallel.com/2006/09/09/mutual-exclusion-with-locks-an-introduction
One of the challenges in programming is to find all section in a code where shared data is accessed. It is really hard to debug a missing \textit{mutex}, 
because the error can not be reproduced that easily and the error may not occur for many runs. Therefore it is very important to comprehensively test programs where multiple threads access shared memory.
A \textit{mutex} variable can have to sates: locked/set and unlocked/reset. 
If a thread wants to access a shared memory the \lstinline{pthread_mutex_lock()} function
\begin{itemize}
    \item locks the \textit{mutex}, if it is currently unlocked
    \item blocks the calling thread, if the \textit{mutex} is already locked by an ohter tread, untill it is unlocked again
    \item might block forever, if the \textit{mutex} which was tired to be locked is already held by the current thread
\end{itemize}

If the tread finished the critical section the \lstinline{pthread_mutex_unlock()} function
\begin{itemize}
    \item unlocks the \textit{mutex}, if the \textit{mutex} was owned by the calling thread
    \item returns an error, if the \textit{mutex} is already unlocked
    \item unlocks the \textit{mutex} or returns an error, if the \textit{mutex} was locked by an other tread, the behavior in this case depends on the type of the \textit{mutex}.
\end{itemize} 
This functionality ensures that no thread can access a critical section in which shared memory is accessed which is currently processed by an other tread.

A \textit{mutex} is created by calling \lstinline{pthread mutex init()} if \lstinline{NULL} is passed as argument to the function, 
the \textit{mutex} will have the default attributes. The ID of the created \textit{mutex} is returend to the calling thread through the \textit{mutex} parameter. 
When a \textit{mutex} is not needed anymore it should be destroyed with \lstinline{pthread_mutex_destroy()}.

\subsubsection{How it was used}

The master-mode function called three threads, which ran parallel as long as the device stays in the master mode. 
Before these threads were stared the connection was set up and configured. Then the function itself only called the threads and waited for them to terminate. 
The threads terminated if the stop signal as described in point \textit{Master Election} was set. If all threads had terminated the function returned.
Each thread contained an infinite loop that did a certain task. The tasks from the master mode has been split up in the following three threads: \\*

\textbf{Broadcast Thread:} \\*
This threads prepared the \textit{updates} and broadcasted them over the network. 
All information needed in the \textit{update} had to be collected and copied in the message before the components got 
converted form host byte order to network byte order using the function \lstinline{htonl()}. After the message was prepared the whole struct was sent. \\

\textbf{Receive Thread:} \\*
This threads waited for \textit{answers} from slave devices, if an \textit{answer} was received a time stamp was saved. 
In the next step the group IDs are compared and it was
checked if the message needs to be precessed any further. If the message was relevant to this master (matching group IDs), the transmission delay was calculated.
For each slave it's individual result was stored separately. To maintain all the active slaves, their transmission delays and the current average delay,
a double linked list was used. Each node of the list held the IP address of a slave, the last round trip delays and as well the current average round trip delay,
 which was calculated with a moving average window. This list made it possible to store information for every slave and easily add or remove slaves from the system.
If a new value had been calculated for a slave the value was stored in the correlating node and the average was built new. 
Also the time when the slave responded the last time was saved. This was used to be able to delete slaves, which were taken of the network and 
didn't respond for a given time. \\
 
\textbf{Check Thread:} \\*
In this threads it was checked if all slaves, which are currently observed by the master were still responding. If a slave was 
not responding any more this treads deleted the correlating node from the list. \\*

There was one more thread which was started in the main function and ran parallel in the master and the slave mode. This thread was
communicating with the player. This thread was necessary for the integration of the synchronization application in the existing system. 

If an event was ready to be initialized a thread which simply held an countdown was stared. This was used the same way in the slave-mode.
This thread terminated right after the countdown was over and the event has been initialized.

\subsection{Flow Chart}

To implementation of the master-mode function can be seen in the graphic on the next page. There can be seen all three threads and the steps in each thread.

\begin{landscape}
\includegraphics[height=\textheight,keepaspectratio]{master-mode.jpg}
\end{landscape}

\section{Slave Mode}

If the device was currently in the slave state, the slave function had to perform the following tasks:
\begin{itemize}
    \item receive \textit{updates} and response to them
    \item communicate with the player
    \item initialize a event if necessary
\end{itemize}

All these tasks were performed in the function itself. In the slave mode the function \lstinline{recvfrom()} waited for an \textit{update} from a master. 
If an \textit{update} had been received in the first step it was checked if the event ID had changed and if an event had to be initialized. 
In the next step all the informations were added to 
the \textit{answer} and the it was sent to the master, from which the \textit{update} was received from. 

\subsection{Flow Chart}

In the following flow chart the steps which are performed in the slave-mode can be seen. \\
\begin{addmargin}{2cm}
\includegraphics[width=0.45\textwidth,keepaspectratio]{slave-mode.jpg}
\end{addmargin}

\section{Integration}

The problem solution also contained the integration of the event synchronization in the existing player, therefor the application had to communicate with
the player. This communication was established with a pipe.

\subsection{Communication with a Pipe}

%ok here what is a pipe and that the set of commands and what they do
% quotes from http://www.gnu.org/software/libc/manual/html_node/Pipes-and-FIFOs.html
A pipe is a mechanism for interprocess communication, data written to the pipe by one process can be read by another process. 
The data in a pipe is handled in a first-in, first-out (FIFO) order, therefore pipes are referred as FIFO in the further descriptions.
A FIFO has to be open at both ends, that means that it can only be written to a FIFO from which is read by a other precess, it also can be read
from a FIFO a other process is writing to.
% http://docs.oracle.com/cd/E19455-01/805-7478/6j71mbrdh/index.html
FIFOs only allow one way communication, that means that one end of a FIFO is used for writing data and the other for reading.
FIFOs are a tool that can be used for unidirectional communication between unrelated processes.
To create a FIFO the following commands can be used \lstinline{mknod()} or \lstinline{mkfifo()}. After a FIFO was created it must be opened by
the processes which should communicate.
They are opened in the same manner as other file system nodes with \lstinline{open()}. After the pipe is opened a process can ether write
\lstinline{write()} or read \lstinline{read()} from it.

% more particular
The player already communicated with other processes on the device over a FIFO. The pipe which was used so far by other programs to 
give commands to the player was called the \lstinline{controller.fifo}, also this application used that pipe to start the event. 
Because pipes only allow unidirectional communication, there was one pipe new created for the player to request events form the synchronization application. 
This pipe was read by the synchronization program and the player wrote to it. In the first steps of the main function it was check if the pipes needed 
for the communication already existed or if they had to be created.

% set of commands
%hallo
If a content was requested to be played in sync, the file had a flag set, which indicated this. The player always loaded the next content 
while playing the current one. When the player loaded a file and the file had the flag set, it wrote a message in the pipe for the synchronization application. 
This message was requesting an event: (\lstinline{sync_req}. The synchronization could deny the request, in this case a \textit{"deny message"} was written 
in the controller pipe for 
the player (\lstinline{sync_deny}). The request was denied if the device was in the slave mode, if the request was denied the device continued playing
the next content which should not be played in sync. If the device was in the master mode, each slave node was notified that the requested 
content should be loaded. The request for loading the content was transmitted over the network with the \textit{update} and on each device the request was written to
the pipe for the player (\lstinline{sync_req}). If a device had finished loading the content, the player notified the synchronization application 
with the message \lstinline{sync_rdy}. The synchronisation program added the information to the \textit{answer} for the master. If all devices had 
successfully loaded the next content, the event was 
initialized by the master. Each device gave the signal to the player to start the content (\lstinline{sync_EVENT}).
Each slave was implemented with an internal countdown which canceled the event (\lstinline{sync_cancel}) if the event was not initialized after a 
request for loading a content. This was designed to prevent
errors if the master device was taken of the network after a request for loading had been sent. \\*

The principle of the communication over the pipes is shown in the graphic below. \\
\includegraphics[width=\textwidth,keepaspectratio]{integration}

\subsection{Options for the User}

There were several configuration options implemented which allowed the users to adjust the program individual for their needs.
This options can be set in a configuration file.

\textbf{sync\_enabled}: \\*
This option specified if the time synchronization was active on the device. A script was run in the background on the device which checked the configuration files 
and started the programs or stops them if the configuration was changed. After the devices was booted the script read the configuration files once and 
started the programs.

\textbf{sync\_group\_id}: \\*
The devices within the same network can be grouped, this option was imported because different devices in the same network could also play different contend 
with the groups it could be specify which devices in the network should be synced together.
If this configuration option was set to -1, which is also the default configuration, the synchronization application was not executed because the device would 
not sync to any other device.

\textbf{sync\_group\_order}: \\*
With the group order a order within the group could be defined. This was useful if the devices should play different content synchronized. 
For example different screens which are ordered next to each other and where each display shows only a part of the same picture 
(or for example two robots which cooperate, each one does a different action but the event must be in perfect sync).

\textbf{sync\_forced\_master}: \\*
%here it would be nice to know why the user needs this option 
As described in the section \textit{"Master Election"} it was possible to manually set a master device. If this option was set
the device was the master node in the system. If this option was not set on one device in the system the master was selected dynamically, 

\textbf{sync\_wait}: \\*
Due to the time drift the played content gets out of sync, if content should be played in sync and one device has not finished the other contend yet, 
there are two options. The default option is that the wait option is set, in this case the devices waited for each other and then started the synced content. 
This can cause the screen to show no content for a short period (usually not longer than 1 to 2 seconds) if this should be avoided the option can be set to false. 
In this case the device was playing some other content which did not need to be in sync. 
If in that case the event was initialized the new content was interrupted by the synced content. 
For this option also special content could be specified, for example pictures are a good option for this purpose.

\chapter{Conclusion and Prospect}

% yehhh an other thing were I have no idea what I should write 

% Literaturverzeichnis
\bibliography{Vorlage_BT_BMR_WS2013_Literatur}
\newpage

% Abbildungsverzeichnis und Tabellenverzeichnis
\begingroup
    \renewcommand*{\addvspace}[1]{}
    \phantomsection
    \addcontentsline{toc}{chapter}{\listfigurename}
    \listoffigures
    \newpage
    %\phantomsection
    %\addcontentsline{toc}{chapter}{\listtablename}
    %\listoftables
\endgroup


% If you use the document class "scrartcl" you need to use  \addsec{List of Abbreviations} instead of \addchap{List of Abbreviations}
\addchap{List of Abbreviations}
\hspace{-17mm}\begin{tabular}{>{\raggedleft}p{0.2\linewidth} p{0.75\linewidth} p{0.1\linewidth}}
www & World Wide Web \\
URL & Uniform Resource Locator \\
UDP & User Datagram Protocol \\
NTP & Network Time Protocol \\
MSC & Message Sequence Chart
\end{tabular}

\begin{appendix}
\chapter[Source Code]{Source Code}

% here comes my hole source in the end

\end{appendix}

\end{document}
